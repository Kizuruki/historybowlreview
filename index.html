<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>History Bowl Study Program</title>
  <link rel="icon" href="290-2900079_dark-green-heart-shape.png" type="image/png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>History Bowl Study Program üíöü§ç</title>

<style>
    /* --------- Visual styles (enhanced with consistent button styling) ---------- */
    *{box-sizing:border-box;margin:0;padding:0}
    body{
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
        min-height:100vh;color:#222;padding:24px;
    }
    .container{max-width:1100px;margin:0 auto;background:transparent}
    #setPickerModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 9999;
      background: rgba(0,0,0,0.4);
      display: none;
      backdrop-filter: blur(4px);
    }
    #setPickerModal > div {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 32px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(60,40,80,0.3);
      min-width: 400px;
      max-width: 96vw;
    }
    #setPickerModal h3 {
      margin-bottom: 20px;
      color: #5a67d8;
      font-size: 1.4rem;
      text-align: center;
    }
    #tipsModal, #rulesModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.45);
      z-index: 9999;
      display: none;
      backdrop-filter: blur(4px);
    }
    
    .tips-modal-content {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      color: #2d3748;
      padding: 28px;
      border-radius: 16px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow: hidden;
      box-shadow: 0 16px 50px rgba(0,0,0,0.25);
    }
    
    .scrollBox {
      overflow-y: auto;
      max-height: 60vh;
      padding-right: 10px;
      margin-bottom: 16px;
    }
    
    .scrollBox::-webkit-scrollbar { width: 6px; }
    .scrollBox::-webkit-scrollbar-thumb {
      background: #5a67d8;
      border-radius: 3px;
}
    .header{text-align:center;color:#fff;margin-bottom:20px}
    .header h1{font-size:2.2rem;text-shadow:2px 2px 4px rgba(0,0,0,0.25)}
    .menu{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px;margin-bottom:16px}
    .card{background:rgba(255,255,255,0.95);padding:18px;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,0.12);cursor:pointer;transition:transform 0.2s,box-shadow 0.2s}
    .card:hover{transform:translateY(-2px);box-shadow:0 12px 32px rgba(0,0,0,0.18)}
    .card h3{color:#5a67d8;margin-bottom:8px}
    .btn{
        background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
        color:white;
        border:none;
        padding:10px 16px;
        border-radius:8px;
        cursor:pointer;
        font-weight:600;
        transition:all 0.2s ease;
        font-size:14px;
        box-shadow:0 2px 8px rgba(102,126,234,0.3);
    }
    .btn:hover{
        transform:translateY(-1px);
        box-shadow:0 4px 12px rgba(102,126,234,0.4);
    }
    .btn:active{
        transform:translateY(0);
    }
    .btn.secondary{
        background:linear-gradient(135deg,#6c757d 0%,#5a6268 100%);
        box-shadow:0 2px 8px rgba(108,117,125,0.3);
        margin-left:8px;
    }
    .btn.secondary:hover{
        box-shadow:0 4px 12px rgba(108,117,125,0.4);
    }
    .btn.success{
        background:linear-gradient(135deg,#28a745 0%,#20c997 100%);
        box-shadow:0 2px 8px rgba(40,167,69,0.3);
    }
    .btn.success:hover{
        box-shadow:0 4px 12px rgba(40,167,69,0.4);
    }
    .btn.outline{
        background:transparent;
        color:#5a67d8;
        border:2px solid #5a67d8;
        box-shadow:none;
    }
    .btn.outline:hover{
        background:#5a67d8;
        color:white;
        box-shadow:0 4px 12px rgba(90,103,216,0.3);
    }
    .btn.danger{
        background:linear-gradient(135deg,#dc3545 0%,#c82333 100%);
        box-shadow:0 2px 8px rgba(220,53,69,0.3);
    }
    .btn.danger:hover{
        box-shadow:0 4px 12px rgba(220,53,69,0.4);
    }
    .modal-btn-group{
        display:flex;
        gap:12px;
        margin-bottom:16px;
        flex-wrap:wrap;
    }
    .modal-btn-group .btn{
        margin:0;
        flex:1;
        min-width:120px;
    }
    .modal-confirm-group{
        display:flex;
        gap:12px;
        justify-content:center;
        margin-top:20px;
    }
    .modal-confirm-group .btn{
        min-width:100px;
    }
    .year-btn-group{
        display:flex;
        gap:8px;
        margin:12px 0;
        justify-content:center;
    }
    .game-area{display:none;margin-bottom:18px}
    .scoreboard{display:flex;gap:12px;align-items:center;background:rgba(255,255,255,0.95);padding:16px;border-radius:12px;margin-bottom:12px;box-shadow:0 4px 16px rgba(0,0,0,0.1)}
    .team-score{flex:1;text-align:center;padding:12px;background:linear-gradient(135deg,#f8f9fa 0%,#ffffff 100%);border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
    .team-name{font-weight:700;color:#5a67d8;margin-bottom:4px}
    .score{font-size:1.6rem;font-weight:800;color:#2d3748}
    .question-area{background:rgba(255,255,255,0.95);padding:20px;border-left:6px solid #5a67d8;border-radius:12px;min-height:110px;box-shadow:0 4px 16px rgba(0,0,0,0.1)}
    .question-text{font-size:1.05rem;color:#2d3748;min-height:62px;line-height:1.5}
    .controls{display:flex;gap:12px;align-items:center;margin-top:16px;flex-wrap:wrap}
    .buzzer-btn{
        background:linear-gradient(135deg,#e53e3e 0%,#c53030 100%);
        color:white;
        padding:14px 24px;
        border-radius:50px;
        border:none;
        font-size:16px;
        font-weight:700;
        cursor:pointer;
        transition:all 0.2s ease;
        box-shadow:0 4px 12px rgba(229,62,62,0.3);
    }
    .buzzer-btn:hover:not(:disabled){
        transform:translateY(-2px);
        box-shadow:0 6px 16px rgba(229,62,62,0.4);
    }
    .buzzer-btn:disabled{
        background:#a0aec0;
        cursor:not-allowed;
        box-shadow:none;
        transform:none;
    }
    .answer-input{
        padding:12px 16px;
        border-radius:10px;
        border:2px solid #e2e8f0;
        font-size:15px;
        width:100%;
        max-width:520px;
        transition:border-color 0.2s;
        background:white;
    }
    .answer-input:focus{
        border-color:#5a67d8;
        outline:none;
        box-shadow:0 0 0 3px rgba(90,103,216,0.1);
    }
    .feedback{margin-top:12px;padding:12px 16px;border-radius:10px;font-weight:600;display:none;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
    .feedback.correct{background:linear-gradient(135deg,#c6f6d5 0%,#9ae6b4 100%);color:#22543d;border:1px solid #9ae6b4}
    .feedback.incorrect{background:linear-gradient(135deg,#fed7d7 0%,#fc8181 100%);color:#742a2a;border:1px solid #fc8181}
    .hidden{display:none}
    .categories{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:16px}
    .category-btn{
        padding:14px 16px;
        border-radius:10px;
        background:white;
        border:2px solid #e2e8f0;
        cursor:pointer;
        text-align:center;
        transition:all 0.2s ease;
        font-weight:500;
        box-shadow:0 2px 8px rgba(0,0,0,0.06);
    }
    .category-btn:hover{
        border-color:#5a67d8;
        transform:translateY(-1px);
        box-shadow:0 4px 12px rgba(0,0,0,0.1);
    }
    .category-btn.selected{
        background:linear-gradient(135deg,#5a67d8 0%,#764ba2 100%);
        color:white;
        border-color:#5a67d8;
        box-shadow:0 4px 12px rgba(90,103,216,0.3);
    }
    .admin-panel{display:none;background:rgba(255,255,255,0.95);padding:20px;border-radius:16px;margin-top:16px;box-shadow:0 8px 24px rgba(0,0,0,0.12)}
    .question-list{background:white;padding:16px;border-radius:10px;max-height:260px;overflow:auto;margin-top:12px;border:1px solid #e2e8f0}
    .controls-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:12px}
    .leaderboard{background:white;padding:16px;border-radius:10px;margin-top:12px;max-height:480px;overflow:auto;border:1px solid #e2e8f0;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
    .small{font-size:0.9rem;color:#000}
    .muted{color:#000;font-size:0.9rem}
    .tab-btn {
        background: #f3f4f6;
        color: #5a67d8;
        border: none;
        border-radius: 8px 8px 0 0;
        padding: 10px 18px;
        margin-right: 6px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tab-btn:hover {
        background: #e5e7eb;
        transform: translateY(-1px);
    }
    .tab-btn.active {
        background: linear-gradient(135deg,#5a67d8 0%,#764ba2 100%);
        color: white;
        box-shadow: 0 4px 8px rgba(90,103,216,0.3);
    }
    .categories.hidden {
      display: none !important;
    }
    .error{
        color:#e53e3e;
        background:linear-gradient(135deg,#fed7d7 0%,#fc8181 100%);
        padding:12px 16px;
        border-radius:10px;
        margin:12px 0;
        border:1px solid #fc8181;
        box-shadow:0 2px 8px rgba(229,62,62,0.2);
    }
    #playerNameInput {
        padding: 10px 16px;
        border-radius: 10px;
        border: 2px solid #e2e8f0;
        font-size: 14px;
        width: 240px;
        transition: all 0.2s ease;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }
    #playerNameInput:focus {
        border-color: #5a67d8;
        outline: none;
        box-shadow: 0 0 0 3px rgba(90,103,216,0.1);
    }
    footer{margin-top:24px;color:#fff;text-align:center;font-size:0.9rem;text-shadow:1px 1px 2px rgba(0,0,0,0.2)}
    @media (max-width:700px){
        .scoreboard{flex-direction:column}
        .modal-btn-group{flex-direction:column}
        .modal-btn-group .btn{min-width:auto}
        #setPickerModal > div{min-width:300px;padding:24px}
    }
    /* Mastered questions modal */
    #masteredModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 9999;
      display: none;
      backdrop-filter: blur(4px);
    }
    #masteredModal > div {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 36px;
      border-radius: 20px;
      max-width: 480px;
      width: 90%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    #masteredModal h2 { color: #5a67d8; margin-bottom: 12px; font-size: 1.6rem; }
    #masteredModal p { color: #4a5568; margin-bottom: 20px; line-height: 1.6; }
</style>
</head>
<body>
  <div class="container">
    <!-- Account Bar -->
    <div class="account-bar" style="position:fixed;top:0;right:0;background:rgba(255,255,255,0.95);padding:8px 16px;border-radius:0 0 0 12px;box-shadow:0 2px 8px rgba(0,0,0,0.1);z-index:1000;display:flex;gap:12px;align-items:center;">
        <span id="username-display">Guest</span>
        <button class="btn" id="loginBtn" onclick="showLoginModal()" style="padding:6px 12px;font-size:13px;">Login</button>
        <button class="btn secondary" id="logoutBtn" onclick="logout()" style="padding:6px 12px;font-size:13px;display:none;">Logout</button>
    </div>
    
    <!-- Login Modal -->
    <div id="loginModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:2000;backdrop-filter:blur(4px);">
      <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:32px;border-radius:16px;max-width:400px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.3);">
        <h2 style="color:#5a67d8;margin-bottom:20px;">Login / Register</h2>
        <form onsubmit="return false;">
          <input type="text" id="loginUsername" placeholder="Username" style="width:100%;padding:10px;margin:8px 0;border-radius:8px;border:2px solid #e2e8f0;font-size:14px;">
          <input type="password" id="loginPassword" placeholder="Password" style="width:100%;padding:10px;margin:8px 0;border-radius:8px;border:2px solid #e2e8f0;font-size:14px;">
        </form>
        <div style="display:flex;gap:12px;margin-top:16px;">
          <button class="btn" onclick="login()">Login</button>
          <button class="btn" onclick="register()">Register</button>
          <button class="btn secondary" onclick="closeLoginModal()">Cancel</button>
        </div>
        <p id="loginError" style="color:#e53e3e;margin-top:12px;"></p>
      </div>
    </div>

    <!-- Mastered Questions Congratulations Modal -->
    <div id="masteredModal">
      <div>
        <h2>üéâ All Questions Mastered!</h2>
        <p>You've correctly answered every question in this practice set at least once. Amazing work!</p>
        <p id="masteredStatsText" style="font-weight:600;color:#5a67d8;"></p>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
          <button class="btn success" onclick="resetMasteredForCurrentSet()">Reset & Practice Again</button>
          <button class="btn secondary" onclick="closeMasteredModal()">Back to Menu</button>
        </div>
      </div>
    </div>

    <!-- Header -->
    <div class="header">
      <h1>üíöü§ç History Bowl Study Program</h1>
      <p class="small">Specific quarter practice + Full-game simulation with response time tracking and leaderboards ü§çüíö</p>
    </div>
    <div id="questionsStatus" class="small muted"></div>
    <div id="questionsDisplay"></div>

    <!-- Set Picker Modal -->
    <div id="setPickerModal" style="display:none;">
      <div>
        <h3>Select Practice Sets</h3>
        <div class="modal-btn-group">
          <button class="btn success" onclick="selectAllSets()">Select All</button>
          <button class="btn outline" onclick="deselectAllSets()">Deselect All</button>
        </div>
        <div id="setPickerTabs"></div>
        <div id="setPickerList" style="max-height:300px;overflow-y:auto;margin-bottom:18px;"></div>
        <div class="year-btn-group">
          <button class="btn secondary" id="selectAllYearBtn">Select All This Year</button>
          <button class="btn outline" id="deselectAllYearBtn">Deselect All This Year</button>
        </div>
        <div id="categoryWeightsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:10000; backdrop-filter:blur(4px);">
          <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border-radius:16px; padding:24px; width:min(480px,94vw); box-shadow:0 20px 60px rgba(0,0,0,.25);">
            <h3 style="margin:0 0 14px; color:#5a67d8;">Category Weights for Practice</h3>
            <p class="small muted" style="margin-bottom:12px;">Adjust weights to control category frequency in practice mode.</p>
        
            <div style="display:grid; gap:12px;">
              <label style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                <span>US History</span>
                <select id="pw_us" class="btn outline" style="min-width:120px;">
                  <option value="1">100%</option>
                  <option value="0.5">50%</option>
                  <option value="0.33">33%</option>
                </select>
              </label>
        
              <label style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                <span>European History</span>
                <select id="pw_eu" class="btn outline" style="min-width:120px;">
                  <option value="1">100%</option>
                  <option value="0.5">50%</option>
                  <option value="0.33">33%</option>
                </select>
              </label>
        
              <label style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                <span>World History</span>
                <select id="pw_world" class="btn outline" style="min-width:120px;">
                  <option value="1">100%</option>
                  <option value="0.5">50%</option>
                  <option value="0.33">33%</option>
                </select>
              </label>
            </div>
        
            <div class="modal-confirm-group" style="margin-top:18px;">
              <button class="btn" id="weightsConfirmBtn">Confirm</button>
              <button class="btn secondary" id="weightsCancelBtn">Cancel</button>
            </div>
          </div>
        </div>
        <div class="modal-confirm-group">
          <button class="btn" onclick="confirmSetPicker()">Confirm</button>
          <button class="btn secondary" onclick="cancelSetPicker()">Cancel</button>
        </div>
      </div>
    </div>
    <!-- Tips Modal -->
    <div id="tipsModal" style="display:none;">
      <div class="tips-modal-content">
        <h3>Tips</h3>
        <div class="scrollBox">
          <ul>
            <li></li>
            <li><strong>PRACTICE MODE TIPS</strong></li>
            <li>- When you're practicing, try to practice the categories you've specialized in.</li>
            <li></li>
            <li>- You can also select specific question sets one by one to try to memorize them.</li>
            <li></li>
            <li>- Study time should be allocated proportional to each category's total question count.</li>
            <li></li>
            <li>- By selecting the categories you're studying in practice mode, bigger categories will be weighed more and show up more often.</li>
            <li></li>
            <li>- When answering questions in practice, all information might be useful information for later, so let the question read out entirely and try to remember all its parts before answering, even if you already know the answer before the question is finished reading.</li>
            <li></li>
            <li>- You can also save questions to PDFs. If you get any wrong or if you want to save specific questions to practice for later, you can check the Add to PDF button. After it moves on to the next question, the question will be added to a PDF, and you can export PDFs with as many questions as you like in the main menu.</li>
            <li></li>
            <li>- I would recommend saving any questions you get wrong to a PDF and exporting it to practice for later.</li>
            <li></li>
            <li>- In Quarter 3, try to pick categories that you don't know so that you can expand your breadth of knowledge, and memorize them as best you can.</li>
            <li></li>
            <li>- Questions you answer correctly in practice are marked as "mastered" and won't appear again in practice (you can reset this per-quarter from the menu).</li>
            <li></li>
            <li><strong>FULL GAME SIMULATION TIPS</strong></li>
            <li>- Full game simulations should be reserved for after you've already practiced a bunch to test your skill, not so much for building knowledge though it can be used for that purpose.</li>
            <li></li>
            <li>- Save any questions you get wrong to PDFs.</li>
            <li></li>
            <li>- No answers use letters or numbers apart from the standard 26 letters and 10 numbers.</li>
            <li></li>
            <li>- Most of the time, the last name of a person will be accepted, so it is generally recommended to only answer the last name (there may be exceptions for common last names or related figures like J Adams and JQ Adams.</li>
            <li></li>
            <li>- Answer as soon as you're pretty sure you're right, in the competition it'll be better to answer earlier before the other team has a chance to, but it's important to find a good balance between your certainty about the answer and the earliness of your buzz (doesn't apply to Q3).</li>
            <li></li>
            <li>- Points are awarded based on the competition's format, but weighted score also takes into account your time to buzz in, giving as much as a 2x bonus decreasing as the question goes on based on the formula: 1+(1-x^{1.2})</li>
            <li></li>
            <li>- (Quarter 2 Bonus questions and Quarter 3 questions all give a static 15 weighted score since you don't have to worry about buzzing in early when the other team can't answer.</li>
          </ul>
        </div>
        <button class="btn secondary closeBtn" onclick="closeTips()">X Close</button>
      </div>
    </div>
    
    <!-- Rules Modal -->
    <div id="rulesModal" style="display:none;">
      <div class="tips-modal-content">
        <h3>Practice Resource Links</h3>
        <div class="scrollBox">
          <ul>
            <li></li>
            <li><strong>HISTORY LINKS</strong></li>
            <li><a href="https://www.iacompetitions.com/resources-national-history-bowl/" target="_blank">Varsity & JV National History Bowl Past Questions</a>: Useful for studying past questions, though the history bowl review program is a better, funner way of studying the same exact content in my opinion.</li>
            <li><a href="https://www.iacompetitions.com/study-guides/" target="_blank">History Bowl Study Guides</a>: (not applicable for set A/February tournaments) KNOW EVERYTHING ON HERE AND LOOK UP EVERYTHING LISTED TO GET DEEPER KNOWLEDGE BEYOND BASIC DESCRIPTION OF IT</li>
            <li><a href="https://en.wikipedia.org/wiki/Timeline_of_the_21st_century" target="_blank">Wikipedia Timeline of the 21st century</a>: good for Recent History questions.</li>
            <li><a href="https://en.wikipedia.org/wiki/2020s" target="_blank">Wikipedia 2020s</a>: better for Recent History questions.</li>
            <li><a href="https://en.wikipedia.org/wiki/2025" target="_blank">Wikipedia 2025</a>: Wikipedia is good in general but for Recent History questions, most will be from events that occured within the last year, so use this and the news to study for that.</li>
            <li><a href="https://www.bbc.com/news/world">BBC News</a>: helpful to keep up with for Recent History questions.</li>
            <li><a href="http://news.bbc.co.uk/2/hi/country_profiles/default.stm" target="_blank">BBC Country Profiles</a>: helpful for general knowledge on countries and their histories.</li>
            <li><a href="https://www.sporcle.com/games/category/history" target="_blank">Sporcle History Quizzes</a>: good for finding random niche history topics to study.</li>
            <li></li>
            <li><strong>GEOGRAPHY LINKS</strong></li>
            <li>Even if you're not studying for the Geography Bowl, some of these links might still be helpful, and a decent knowledge of geography is helpful for the History Bowl. All the geography links are good for studying, don't just stick to one or the other. Don't be afraid to look for geography stuff in other places too!</li>
            <li><a href="https://www.cia.gov/the-world-factbook/countries/" target="_blank">CIA World Factbook</a>: very good for basic knowledge on all aspects of countries, which does come in handy.</li>
            <li><a href="https://www.sporcle.com/games/category/geography" target="_blank">Sporcle Geography Quizzes</a>: good for finding random & niche geography topics to study.</li>
            <li><a href="https://www.geoguessr.com/quiz/seterra" target="_blank">Seterra Geography Quizzes</a>: extremely helpful for memorizing country locations, regional and national capitals, borders, flags, and sports teams.</li>
            <li><a href="https://historybowlreview.github.io/geographybowlreview/" target="_blank">Geography Bowl Study Program</a>: not as useful for geography as the history bowl review is for history, but it still has a decent amount of questions.</li>
            <li><a href="https://www.factmonster.com/world/geography/world-geography" target="_blank">Fact Monster Geography</a>: random geography stuff, might be useful.</li>
            <li>You should also refer to atlases/encyclopedias/wikipedia for maps, lists of things, and anything else you might need, you could also use ai or friends to ask you questions on specific stuff if quiz websites aren't available.</li>
            <li></li>
            <li><strong>For Geography, you should know:</strong></li>
            <li>Superlatives (top 5/10 in the world and the top 1 per continent~ of): Highest Peaks, Lowest Points, Largest/Smallest Populations, Largest Deserts, Largest Islands, Largest/Smallest Countries, Wealthiest/Poorest Countries, Largest/Smallest Lakes, Largest/Smallest Rivers, Largest/Smallest Seas, Largest/Smallest Oceans etc.</li>
            <li></li>
            <li>All national capitals, state capitals of US, regions and regional capitals of Canada, regions of other important countries/what they're called/known for, currencies, exports, etc, pop culturally significant locations (Jaws/star wars film locations e.g.), landmarks, etc.</li>
            <li></li>
            <li>Locations (continent and countries/US States) of mountain ranges, lakes, rivers, seas, oceans, significant islands, etc.</li>
            <li></li>
            <li>There will be random geography facts mentioned so I would absorb any fun facts or weird facts you may find or hear.</li>
          </ul>
        </div>
        <button class="btn secondary closeBtn" onclick="closeRules()">X Close</button>
      </div>
    </div>
    <!-- Player Name Input (MOVE THIS OUTSIDE) -->
    <div id="playerNameContainer" style="text-align:center; margin-bottom: 16px;">
      <input type="text" id="playerNameInput" placeholder="Enter your name for leaderboard" maxlength="20">
    </div>
    <!-- Main Menu -->
    <div id="mainMenu" class="menu">
      <div class="card" onclick="openPracticeMode()">
        <h3>üéØ Practice Mode</h3>
        <p class="muted">Pick a quarter to practice specific formats and question types.</p>
        <div style="margin-top:10px"><button class="btn">Start Practice</button></div>
      </div>
      <div class="card" onclick="startFullGameFromMenu()">
        <h3>üèÜ Full Game Simulation</h3>
        <p class="muted">Play a full match (Q1‚ÜíQ4) with official scoring.</p>
        <div style="margin-top:10px"><button class="btn">Start Full Game</button></div>
      </div>
      <div class="card" onclick="showLeaderboardPanel()">
        <h3>üèÖ Global Leaderboard</h3>
        <p class="muted">Shows all full game attempts ordered by score. Enter your name to save it with your score.</p>
        <div style="margin-top:10px"><button class="btn">View Leaderboard</button></div>
      </div>
      <div class="card">
        <h3>PDFs</h3>
        <button class="btn" onclick="exportPDFs()">Export PDFs</button>
        <button class="btn" onclick="clearPDFQuestions()">Clear PDFs</button>
        <button class="btn" onclick="generateSamplePDFs()">Generate Practice PDFs</button>
      </div>
      <div class="card">
        <h3>Tips & Links</h3>
        <button class="btn secondary" onclick="showTips()">Tips</button>
        <button class="btn secondary" onclick="showRules()">Links</button>
      </div>
      <div class="card" onclick="openKnowledgeGraph()">
          <h3>üï∏Ô∏è Knowledge Graph</h3>
          <p class="muted">Visual map of all topics with AI summaries and progress tracking.</p>
          <div style="margin-top:10px"><button class="btn">Open Graph</button></div>
      </div>
      <div class="card" onclick="startMissedQuestionsMode()">
          <h3>üîÑ Missed Questions</h3>
          <p class="muted">Review questions you got wrong until you master them.</p>
          <div style="margin-top:10px"><button class="btn">Start Review</button></div>
      </div>
      <div class="card">
          <h3>üèÜ Mastered Questions</h3>
          <p class="muted">Questions you've answered correctly are skipped in practice. Reset them here.</p>
          <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn outline" onclick="showMasteredStats()">View Stats</button>
            <button class="btn danger" onclick="confirmResetMastered()">Reset All</button>
          </div>
      </div>
    </div>

    <!-- Game Area -->
  <div id="gameArea" class="game-area">
    <div class="scoreboard" style="display:block">
      <div style="display:flex;gap:20px;margin-bottom:12px">
        <div class="team-score" style="flex:2">
          <div class="team-name">Score</div>
          <div class="score" id="rawScore">0</div>
          <div class="small muted" id="weightedScoreDisplay" style="font-size:0.95rem;margin-top:6px;">Weighted: 0</div>
          <div class="small muted">Total points</div>
        </div>
        <div style="text-align:center;flex:1;display:flex;flex-direction:column;justify-content:center">
          <div class="small">Quarter</div>
          <div id="quarterDisplay" style="font-weight:700">1</div>
          <div id="questionCounter" class="small muted">Q 0 / 0</div>
        </div>
        <div style="flex:2;display:flex;gap:8px">
          <div class="team-score" style="flex:1">
            <div class="team-name">Avg Buzz-in</div>
            <div class="score" id="avgResponseTime">--</div>
            <div class="small muted">Seconds to buzz</div>
          </div>
          <div class="team-score" style="flex:1">
            <div class="team-name">Accuracy</div>
            <div class="score" id="accuracyDisplay">--%</div>
            <div class="small muted">Questions correct</div>
          </div>
        </div>
      </div>
    </div>
    <div style="text-align:center;padding:16px 0;color:#fff">
      <div style="font-size:0.875rem;margin-bottom:4px">Timer</div>
      <div id="timerDisplay" style="font-weight:700;font-size:1.25rem">--</div>
    </div>
    <div id="q3PrefixBox" class="hidden" style="font-weight:600;font-size:1.08em;margin-bottom:6px;"></div>
    <div class="question-area">
      <div id="questionText" class="question-text">Load questions first, then click "Next Question" to begin.</div>
    </div>
    <div class="controls">
      <button id="buzzerBtn" class="buzzer-btn" onclick="buzz()" disabled>üîî BUZZ</button>
      <button class="btn secondary" id="showAnswerBtn" onclick="showAnswer()">Show Answer</button>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div class="small muted">Mode:</div>
        <div id="modeDisplay" style="font-weight:700">Practice</div>
      </div>
    </div>
    <div class="controls-row">
      <input id="answerInput" class="answer-input" placeholder="Type answer and press Enter or Submit..." disabled>
      <button id="submitBtn" class="btn" onclick="submitAnswer()">Submit</button>
      <div id="currentResponseTime" class="small muted">Response time: --</div>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer;margin-left:12px;">
        <input type="checkbox" id="addToPDFCheckbox" style="width:18px;height:18px;cursor:pointer;">
        <span style="font-size:0.9rem;color:#2d3748;font-weight:500;">Add to PDF</span>
      </label>
    </div>
    <div id="feedback" class="feedback"></div>
      <!-- Q3 category selection area -->
    <div id="categorySelection" class="categories hidden"></div>
      <!-- Controls to go back or reset -->
    <div class="controls-row" style="margin-top:12px">
      <button class="btn secondary" onclick="backToMenu()">Back to Menu</button>
      <button class="btn secondary" id="pauseBtn" onclick="togglePause()">Pause</button>
      <button class="btn" onclick="resetPracticeGame()">Reset Game</button>
    </div>
  </div>

    <!-- Leaderboard Panel -->
    <div id="leaderboardPanel" class="admin-panel hidden">
      <h3 style="text-align:center;color:#5a67d8;margin-bottom:20px;font-size:1.6rem">üèÖ Global Leaderboard (weighted by points and buzz in times)</h3>
      <div style="display:flex;gap:8px;margin-bottom:12px;align-items:center;justify-content:center">
        <button class="btn secondary" onclick="backToMenu()">Back to Menu</button>
      </div>
      <div class="leaderboard" id="leaderboardList">
        <!-- Sample leaderboard entries for demonstration -->
      </div>
    </div>
    <footer>
      <p><i>Made by Kizuruki</i></p>
    </footer>
  </div>
<script>
/* ================================================================
   Game state & helpers
   ================================================================ */
const FULL_GAME_SET_MODE = 'A';
const WORKER_URL = "https://patient-base-c952.javalutionization.workers.dev";
let currentUser = null;
let missedQuestions = [];
let knowledgeGraphNodes = [];
let practiceCategoryWeights = { us: 1, eu: 1, world: 1 };
let practiceCategorySelection = 'A';

// ============================================================
// MASTERED QUESTIONS SYSTEM
// ============================================================
// masteredQuestions: Set of question keys (globally, per user)
// Key format: "Q{quarter}|{first 100 chars of normalized question}"
let masteredQuestions = new Set();

function makeMasteredKey(quarter, questionText) {
    const normalized = String(questionText || '').toLowerCase().replace(/\s+/g, ' ').trim().slice(0, 100);
    return `Q${quarter}|${normalized}`;
}

async function loadMasteredQuestions() {
    if (!currentUser) {
        // Load from localStorage for guests
        const saved = localStorage.getItem('masteredQuestions_guest');
        if (saved) {
            try { masteredQuestions = new Set(JSON.parse(saved)); } catch(e) { masteredQuestions = new Set(); }
        }
        return;
    }
    try {
        const res = await fetch(`${WORKER_URL}/mastered/${currentUser}`);
        if (res.ok) {
            const data = await res.json();
            masteredQuestions = new Set(Array.isArray(data) ? data : []);
            console.log(`‚úì Loaded ${masteredQuestions.size} mastered questions`);
        } else {
            const saved = localStorage.getItem('masteredQuestions_' + currentUser);
            if (saved) {
                try { masteredQuestions = new Set(JSON.parse(saved)); } catch(e) { masteredQuestions = new Set(); }
            }
        }
    } catch (err) {
        console.warn('Failed to load mastered from server, using localStorage:', err);
        const saved = localStorage.getItem('masteredQuestions_' + (currentUser || 'guest'));
        if (saved) {
            try { masteredQuestions = new Set(JSON.parse(saved)); } catch(e) { masteredQuestions = new Set(); }
        }
    }
}

async function saveMasteredQuestions() {
    const arr = Array.from(masteredQuestions);
    const storageKey = 'masteredQuestions_' + (currentUser || 'guest');
    localStorage.setItem(storageKey, JSON.stringify(arr));

    if (!currentUser) return;
    try {
        await fetch(`${WORKER_URL}/mastered/${currentUser}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(arr)
        });
    } catch (err) {
        console.warn('Failed to save mastered to server:', err);
    }
}

function markQuestionMastered(quarter, questionText) {
    if (gameState.mode !== 'practice') return; // only in practice
    const key = makeMasteredKey(quarter, questionText);
    if (!masteredQuestions.has(key)) {
        masteredQuestions.add(key);
        saveMasteredQuestions();
    }
}

function isQuestionMastered(quarter, questionText) {
    return masteredQuestions.has(makeMasteredKey(quarter, questionText));
}

// Filter out mastered questions from a Q1 array
function filterMasteredQ1(arr) {
    if (!arr) return arr;
    return arr.filter(q => !isQuestionMastered(1, q.question));
}

// Filter out mastered questions from a Q2 array (checks tossup question)
function filterMasteredQ2(arr) {
    if (!arr) return arr;
    return arr.filter(q => !isQuestionMastered(2, q.tossup?.question || ''));
}

// Filter out mastered questions from a Q4 array
function filterMasteredQ4(arr) {
    if (!arr) return arr;
    return arr.filter(q => !isQuestionMastered(4, (q.parts || []).join(' ')));
}

function showMasteredModal(quarter) {
    const total = masteredQuestions.size;
    $('masteredStatsText').textContent = `${total} questions mastered across all quarters.`;
    gameState._masteredModalQuarter = quarter;
    $('masteredModal').style.display = 'block';
}

function closeMasteredModal() {
    $('masteredModal').style.display = 'none';
    backToMenu();
}

function resetMasteredForCurrentSet() {
    $('masteredModal').style.display = 'none';
    // Reset only the quarter that ran out
    const quarter = gameState._masteredModalQuarter || gameState.currentQuarter;
    const prefix = `Q${quarter}|`;
    const toRemove = Array.from(masteredQuestions).filter(k => k.startsWith(prefix));
    toRemove.forEach(k => masteredQuestions.delete(k));
    saveMasteredQuestions();
    // Reload and continue
    openPracticeMode();
}

// ============================================================
// END MASTERED QUESTIONS SYSTEM
// ============================================================

function extractSetLetterFromAny(obj) {
  const hay = [obj.file, obj.source, obj.setName, obj.category, obj.title].filter(Boolean).join(' ');
  let m = hay.match(/\/([ABC])\d{4}-\d{4}/i);
  if (m) return m[1].toUpperCase();
  m = hay.match(/\b([ABC])\b(?![a-z])/i);
  if (m) return m[1].toUpperCase();
  return null;
}

function parseLetters(mode) {
  if (!mode || String(mode).toLowerCase() === 'mixed') return null;
  const letters = new Set(String(mode).toUpperCase().replace(/[^ABC]/g, '').split(''));
  return letters.size ? letters : null;
}

function filterByLetters(items, letters) {
  if (!letters) return items;
  return items.filter(it => {
    const L = extractSetLetterFromAny(it);
    return L ? letters.has(L) : false;
  });
}

function openCategoryWeightsModal(defaults = { us: 1, eu: 1, world: 1 }) {
  return new Promise((resolve) => {
    const m = $('categoryWeightsModal');
    const wUS = $('pw_us'), wEU = $('pw_eu'), wWorld = $('pw_world');
    wUS.value = String(defaults.us);
    wEU.value = String(defaults.eu);
    wWorld.value = String(defaults.world);

    const onConfirm = () => { cleanup(); resolve({ us: parseFloat(wUS.value), eu: parseFloat(wEU.value), world: parseFloat(wWorld.value) }); };
    const onCancel = () => { cleanup(); resolve(null); };

    function cleanup() {
      $('weightsConfirmBtn').removeEventListener('click', onConfirm);
      $('weightsCancelBtn').removeEventListener('click', onCancel);
      m.style.display = 'none';
    }

    $('weightsConfirmBtn').addEventListener('click', onConfirm);
    $('weightsCancelBtn').addEventListener('click', onCancel);
    m.style.display = 'block';
  });
}

function weightedPickCategories(categories, weights) {
  const items = [];
  for (const c of categories) {
    const name = (c.category || '').toLowerCase();
    let w = 1;
    if (name.includes('us history')) w = weights.us;
    else if (name.includes('european history')) w = weights.eu;
    else if (name.includes('world history')) w = weights.world;
    w = Math.max(0.001, w);
    const copies = Math.max(1, Math.round(w * 100));
    for (let i = 0; i < copies; i++) items.push(c);
  }
  const picked = [];
  const seen = new Set();
  while (picked.length < Math.min(3, items.length) && items.length) {
    const x = items[Math.floor(Math.random() * items.length)];
    const key = x.category + '|' + (x.prompt || '');
    if (!seen.has(key)) { seen.add(key); picked.push(x); }
  }
  return picked;
}

let QUESTIONS = { q1: [], q2: [], q3: [], q4: [] };

async function loadQuestionsFromServer() { 
    try {
        const response = await fetch('questions.json');
        if (!response.ok) throw new Error("Failed to load questions.json");
        const jsonData = await response.json();
        if (!jsonData.q1 || !jsonData.q2 || !jsonData.q3 || !jsonData.q4) throw new Error("questions.json must contain q1, q2, q3, q4");
        QUESTIONS = jsonData;
        gameState.questionsLoaded = true;
        const q1Count = jsonData.q1?.length || 0;
        const q2Count = jsonData.q2?.length || 0;
        const q3Count = (jsonData.q3 || []).reduce((sum, cat) => sum + (cat.questions?.length || 0), 0);
        const q4Count = (jsonData.q4 || []).reduce((sum, group) => sum + (group.parts?.length || 0), 0);
        updateQuestionsStatus(`Successfully loaded ${q1Count + q2Count + q3Count + q4Count} questions`, true);
        renderQuestionsDisplay();
    } catch (err) {
        updateQuestionsStatus("Error: " + err.message, false);
        gameState.questionsLoaded = false;
        console.error(err);
    }
}

let QUESTIONS_SETS = [];
function showTips() { $('tipsModal').style.display = 'block'; }
function closeTips() { $('tipsModal').style.display = 'none'; }
function showRules() { $('rulesModal').style.display = 'block'; }
function closeRules() { $('rulesModal').style.display = 'none'; }

async function loadAllQuestionSets(files) {
    QUESTIONS_SETS = [];
    for (const file of files) {
        const response = await fetch(file);
        const data = await response.json();
        QUESTIONS_SETS.push(data);
    }
    gameState.questionsLoaded = true;
}

let _selectedSets = {};

function selectAllSets() {
    _selectedSets = {};
    window._setPickerFiles.forEach((yearGroup, yearIdx) => {
        if (yearGroup.year === "Categories") return;
        yearGroup.sets.forEach((set, setIdx) => { _selectedSets[`${yearIdx}-${setIdx}`] = true; });
    });
    renderSetList(window._setPickerCurrentYearIdx);
}

function deselectAllSets() {
    _selectedSets = {};
    renderSetList(window._setPickerCurrentYearIdx);
}

function openSetPicker(availableFiles, callback, title = 'Select Practice Sets') {
    window._setPickerCallback = callback;
    window._setPickerFiles = availableFiles;
    const tabsContainer = $('setPickerTabs');
    const list = $('setPickerList');
    const header = $('setPickerModal').querySelector('h3');
    if (header) header.textContent = title;
    tabsContainer.innerHTML = '';
    list.innerHTML = '';
    availableFiles.forEach((group, idx) => {
        const tab = document.createElement('button');
        tab.textContent = group.year;
        tab.className = 'tab-btn';
        tab.onclick = () => renderSetList(idx);
        tabsContainer.appendChild(tab);
    });
    renderSetList(0);
    $('setPickerModal').style.display = 'block';
}

function confirmSetPicker() {
    const modal = $('setPickerModal');
    const selected = [];
    Object.keys(_selectedSets).forEach(key => {
        if (_selectedSets[key]) {
            const [yearIdx, setIdx] = key.split('-').map(Number);
            const file = window._setPickerFiles[yearIdx].sets[setIdx].file;
            selected.push(file);
        }
    });
    if (selected.length === 0) { alert('Please select at least one set.'); return; }
    modal.style.display = 'none';
    window._setPickerCallback(selected);
}

function renderSetList(yearIdx) {
    window._setPickerCurrentYearIdx = yearIdx;
    const list = $('setPickerList');
    list.innerHTML = '';
    const sets = window._setPickerFiles[yearIdx].sets;

    const groupsByType = { regular: {}, categories: {} };
    sets.forEach((set, idx) => {
        const file = set.file || '';
        if (file.includes('/categories/')) {
            const m = file.match(/\/categories\/([a-z])\//i);
            const letter = m ? m[1].toUpperCase() : 'Other';
            if (!groupsByType.categories[letter]) groupsByType.categories[letter] = [];
            groupsByType.categories[letter].push({ ...set, idx });
        } else {
            const m = file.match(/\/([A-Z])\d{4}-\d{4}/);
            const letter = m ? m[1] : 'Other';
            if (!groupsByType.regular[letter]) groupsByType.regular[letter] = [];
            groupsByType.regular[letter].push({ ...set, idx });
        }
    });

    function renderTypeSections(typeLabel, groupMap) {
        const letters = Object.keys(groupMap).sort();
        if (letters.length === 0) return;
        const typeBlock = document.createElement('div');
        typeBlock.style.marginBottom = '12px';
        const typeHeader = document.createElement('h3');
        typeHeader.textContent = typeLabel;
        typeHeader.style.margin = '8px 0';
        typeHeader.style.fontSize = '14px';
        typeHeader.style.color = '#111827';
        typeHeader.style.fontWeight = '700';
        typeBlock.appendChild(typeHeader);
        
        if (typeLabel === 'Category Sets') {
            const weightRow = document.createElement('div');
            weightRow.style.display = 'grid';
            weightRow.style.gridTemplateColumns = 'repeat(auto-fit,minmax(180px,1fr))';
            weightRow.style.gap = '8px';
            weightRow.style.margin = '8px 0 12px';
            function makePicker(labelText, id, key) {
              const wrap = document.createElement('label');
              wrap.style.display = 'flex';
              wrap.style.justifyContent = 'space-between';
              wrap.style.alignItems = 'center';
              wrap.style.gap = '8px';
              wrap.innerHTML = `<span>${labelText}</span><select id="${id}" class="btn outline" style="min-width:120px;"><option value="1">100%</option><option value="0.5">50%</option><option value="0.33">33%</option></select>`;
              wrap.querySelector('select').value = String(practiceCategoryWeights[key] ?? 1);
              wrap.querySelector('select').onchange = (e) => { practiceCategoryWeights[key] = parseFloat(e.target.value); };
              return wrap;
            }
            weightRow.appendChild(makePicker('US History','picker_us','us'));
            weightRow.appendChild(makePicker('European History','picker_eu','eu'));
            weightRow.appendChild(makePicker('World History','picker_world','world'));
            typeBlock.appendChild(weightRow);
        }

        letters.forEach(letter => {
            const section = document.createElement('div');
            section.style.marginBottom = '8px';
            const headerContainer = document.createElement('div');
            headerContainer.style.display = 'flex';
            headerContainer.style.justifyContent = 'space-between';
            headerContainer.style.alignItems = 'center';
            headerContainer.style.background = '#f3f4f6';
            headerContainer.style.padding = '6px';
            headerContainer.style.borderRadius = '6px 6px 0 0';
            headerContainer.style.cursor = 'pointer';
            const header = document.createElement('div');
            header.textContent = (typeLabel === 'Category Sets') ? `Categories Set ${letter}` : `Set ${letter}`;
            header.style.fontWeight = 'bold';
            header.style.flex = '1';
            const buttonGroup = document.createElement('div');
            buttonGroup.style.display = 'flex';
            buttonGroup.style.gap = '4px';
            buttonGroup.style.marginLeft = '12px';
            const selectBtn = document.createElement('button');
            selectBtn.className = 'btn success';
            selectBtn.textContent = 'Select All';
            selectBtn.style.padding = '4px 8px';
            selectBtn.style.fontSize = '11px';
            selectBtn.onclick = (e) => { e.stopPropagation(); groupMap[letter].forEach(set => { _selectedSets[`${yearIdx}-${set.idx}`] = true; }); renderSetList(yearIdx); };
            const deselectBtn = document.createElement('button');
            deselectBtn.className = 'btn outline';
            deselectBtn.textContent = 'Deselect All';
            deselectBtn.style.padding = '4px 8px';
            deselectBtn.style.fontSize = '11px';
            deselectBtn.onclick = (e) => { e.stopPropagation(); groupMap[letter].forEach(set => { delete _selectedSets[`${yearIdx}-${set.idx}`]; }); renderSetList(yearIdx); };
            buttonGroup.appendChild(selectBtn);
            buttonGroup.appendChild(deselectBtn);
            headerContainer.appendChild(header);
            headerContainer.appendChild(buttonGroup);
            section.appendChild(headerContainer);
            const content = document.createElement('div');
            content.style.padding = '8px';
            content.style.border = '1px solid #e2e8f0';
            content.style.borderTop = 'none';
            groupMap[letter].forEach(set => {
                const div = document.createElement('div');
                div.innerHTML = `<label><input type="checkbox" value="${yearIdx}-${set.idx}" ${_selectedSets[`${yearIdx}-${set.idx}`] ? "checked" : ""}>${set.name}</label>`;
                content.appendChild(div);
                const input = div.querySelector('input[type=checkbox]');
                input.checked = !!_selectedSets[`${yearIdx}-${set.idx}`];
                input.onchange = function () { _selectedSets[`${yearIdx}-${set.idx}`] = input.checked; };
            });
            section.appendChild(content);
            headerContainer.onclick = (e) => { if (e.target.tagName === 'BUTTON') return; content.style.display = (content.style.display === 'none') ? 'block' : 'none'; };
            content.style.display = 'block';
            typeBlock.appendChild(section);
        });
        list.appendChild(typeBlock);
    }

    renderTypeSections('Regular Sets', groupsByType.regular);
    renderTypeSections('Category Sets', groupsByType.categories);

    $('selectAllYearBtn').onclick = function () {
        window._setPickerFiles[yearIdx].sets.forEach((set, setIdx) => { _selectedSets[`${yearIdx}-${setIdx}`] = true; });
        renderSetList(yearIdx);
    };
    $('deselectAllYearBtn').onclick = function () {
        window._setPickerFiles[yearIdx].sets.forEach((set, setIdx) => { delete _selectedSets[`${yearIdx}-${setIdx}`]; });
        renderSetList(yearIdx);
    };
}

function cancelSetPicker() {
    $('setPickerModal').style.display = 'none';
    window._setPickerCallback(null);
    backToMenu();
}

function getRandomItem(array) { return array[Math.floor(Math.random() * array.length)]; }

function getRandomQ1() { if (!QUESTIONS.q1.length) return null; return getRandomItem(QUESTIONS.q1); }
function getRandomQ2() { if (!QUESTIONS.q2.length) return null; return getRandomItem(QUESTIONS.q2); }
function getRandomQ3() {
    if (!QUESTIONS.q3.length) return [];
    const shuffledCategories = [...QUESTIONS.q3].sort(() => Math.random() - 0.5);
    return shuffledCategories.slice(0, 3);
}
function getRandomQ4Part() {
    if (!QUESTIONS.q4.length) return null;
    const group = getRandomItem(QUESTIONS.q4);
    return getRandomItem(group.parts);
}

function updateQ3PrefixBox(show) {
    const box = $('q3PrefixBox');
    if (show) { box.textContent = "Millard Fillmore is or was..."; box.classList.remove('hidden'); }
    else { box.classList.add('hidden'); box.textContent = ""; }
}

function computePercentDisplayed() {
    const text = stripTiebreakerPrefix(gameState.currentQuestionText || "");
    const total = Math.max(1, text.length);
    const originalText = gameState.currentQuestionText || "";
    const prefixLength = originalText.length - text.length;
    const adjustedIndex = Math.max(0, (gameState.readingCharIndex || total) - prefixLength);
    const shown = Math.max(0, Math.min(total, adjustedIndex));
    return shown / total;
}

function computeWeightedIncrement(basePoints, opts = {}) {
    if (!basePoints || basePoints <= 0) return 0;
    if (opts.isQ3 || opts.isQ2Bonus) return basePoints * 1.5;
    const pct = (typeof opts.percentDisplayed === 'number') ? opts.percentDisplayed : computePercentDisplayed();
    const clamped = Math.max(0, Math.min(1, pct));
    const multiplier = 1 + (1 - Math.pow(clamped, 1.2));
    return basePoints * multiplier;
}

let gameState = {
    mode: null,
    currentQuarter: 1,
    q3CategoryQuestions: [],
    q3Timer: null,
    q3TimeLeft: 60,
    pdfQuestions: { q1: [], q2: [], q3: [], q4: [] },
    q3CurrentQuestionIdx: 0,
    q3CategoryActive: false,
    currentQuestionIndex: -1,
    rawScore: 0,
    questionsAttempted: 0,
    questionsCorrect: 0,
    weightedScore: 0,
    responseTimes: [],
    readingInterval: null,
    postReadTimer: null,
    answerTimer: null,
    readingCharIndex: 0,
    q4CurrentPart: 0,
    currentQuestionText: "",
    isPaused: false,
    savedIntervals: {},
    currentAnswer: "",
    currentBonus: null,
    buzzed: false,
    buzzInTimes: [],
    multiplier: 1,
    pausedPostReadTime: null,
    pausedAnswerTime: null,
    wasReading: false,
    q3selectedCategory: null,
    q3categoryProgress: 0,
    q3categoryCorrectCount: 0,
    q3Swept: false,
    lastActionTimestamp: null,
    questionStartTime: null,
    buzzTime: null,
    questionsLoaded: false,
    nextQuestionTimer: null,
    nextQuestionDelay: null,
    pausedNextQuestionTime: null,
    feedbackTimer: null,
    feedbackTimeLeft: null,
    pausedFeedbackTime: null
};

const $ = id => document.getElementById(id);

function updateQuestionsStatus(message, success) {
    const statusEl = $('questionsStatus');
    statusEl.textContent = message;
    statusEl.className = success ? 'small muted' : 'small error';
}

function updateScoreDisplays(){
    $('rawScore').textContent = gameState.rawScore;
    $('weightedScoreDisplay').textContent = 'Weighted: ' + (Math.round(gameState.weightedScore || 0));
    const avgBuzz = calculateAverageBuzzInTime();
    $('avgResponseTime').textContent = avgBuzz !== null ? avgBuzz.toFixed(1) + 's' : '--';
    const att = gameState.questionsAttempted || 0;
    $('accuracyDisplay').textContent = att ? Math.round(100 * (gameState.questionsCorrect || 0) / att) + '%' : '--%';
    $('quarterDisplay').textContent = gameState.currentQuarter;
}

function calculateAverageResponseTime() {
    if (gameState.responseTimes.length === 0) return null;
    const sum = gameState.responseTimes.reduce((a, b) => a + b, 0);
    return sum / gameState.responseTimes.length;
}

function looseMatch(given, answer) {
    const allowedExtras = ["the","a","an","of","in","on","at","for","by","to","from","with","and","or","el","la","los","las","saint","st","d","de","du","des","le","les","un","une","van","von","der","die","das"];
    function normalizeWord(word) {
        word = word.toLowerCase().replace(/[.,;:!?]/g, '');
        if (word === "saint" || word === "st" || word === "st.") return "saint";
        if (word.endsWith('st') || word.endsWith('nd') || word.endsWith('rd') || word.endsWith('th')) {
            const numPart = word.slice(0, -2);
            if (!isNaN(numPart) && numPart !== '') return numPart;
        }
        const wordToNum = {"one":"1","first":"1","I":"1","two":"2","second":"2","II":"2","three":"3","third":"3","III":"3","four":"4","fourth":"4","IV":"4","five":"5","fifth":"5","V":"5","six":"6","sixth":"6","VI":"6","seven":"7","seventh":"7","VII":"7","eight":"8","eighth":"8","VIII":"8","nine":"9","ninth":"9","IX":"9","ten":"10","tenth":"10","X":"10","eleven":"11","eleventh":"11","XI":"11","twelve":"12","twelfth":"12","XII":"12","thirteen":"13","thirteenth":"13","fourteen":"14","fourteenth":"14","XIV":"14","fifteen":"15","fifteenth":"15","XV":"15","sixteen":"16","sixteenth":"16","XVI":"16","seventeen":"17","seventeenth":"17","XVII":"17","eighteen":"18","eighteenth":"18","XVIII":"18","nineteen":"19","nineteenth":"19","XIX":"19","twenty":"20","twentieth":"20","XX":"20"};
        if (wordToNum[word]) return wordToNum[word];
        const variations = generateWordVariations(word);
        return variations.length === 1 ? variations[0] : variations;
    }
    function generateWordVariations(word) {
        const variations = new Set([word]);
        if (word.length > 3 && word.endsWith('ies')) variations.add(word.slice(0, -3) + 'y');
        if (word.length > 2 && word.endsWith('es')) variations.add(word.slice(0, -2));
        if (word.length > 2 && word.endsWith('s')) variations.add(word.slice(0, -1));
        variations.add(word + 's');
        if (!word.endsWith('y')) variations.add(word + 'es');
        if (word.length > 1 && word.endsWith('y')) variations.add(word.slice(0, -1) + 'ies');
        return Array.from(variations);
    }
    function tokenizeAndNormalize(s) {
        return s.toLowerCase().replace(/[^a-z0-9' -]/g, ' ').split(/\s+/).filter(w => w && !allowedExtras.includes(w.replace(/[.,;:!?]/g, ''))).map(normalizeWord);
    }
    function possibleAnswers(ans) {
        if (Array.isArray(ans)) return ans;
        if (typeof ans === "string" && ans.includes(",")) return ans.split(",").map(s => s.trim());
        return [ans];
    }
    const givenNorm = tokenizeAndNormalize(given);
    function matchWordSets(givenTokens, answerTokens) {
        const flattenVariations = (tokens) => { const result = []; tokens.forEach(token => { if (Array.isArray(token)) result.push(...token); else result.push(token); }); return result; };
        const givenFlat = flattenVariations(givenTokens);
        const answerFlat = flattenVariations(answerTokens);
        const givenWordCount = givenTokens.length;
        const answerWordCount = answerTokens.length;
        if (givenWordCount === answerWordCount) { if (givenFlat.some(g => answerFlat.includes(g))) return true; }
        if (answerWordCount < givenWordCount) { if (answerFlat.every(a => givenFlat.includes(a))) return true; }
        return false;
    }
    for (let ans of possibleAnswers(answer)) {
        const ansNorm = tokenizeAndNormalize(ans);
        if (matchWordSets(givenNorm, ansNorm)) return true;
        const givenNoApostrophe = tokenizeAndNormalize(given.replace(/'s/g, '').replace(/'/g, ''));
        const ansNoApostrophe = tokenizeAndNormalize(ans.replace(/'s/g, '').replace(/'/g, ''));
        if (matchWordSets(givenNoApostrophe, ansNoApostrophe)) return true;
        if (ans.includes("joint-stock company") || ans.includes("joint stock company")) {
            const normalizedGiven = given.replace(/[']/g, '').toLowerCase();
            const normalizedAns = ans.replace(/[']/g, '').toLowerCase();
            if ((normalizedGiven.includes("joint stock company") && normalizedAns.includes("joint-stock company")) || (normalizedGiven.includes("joint-stock company") && normalizedAns.includes("joint stock company"))) return true;
        }
    }
    return false;
}

function preprocessAnswer(ans) {
  if (!ans) return ans;
  let processedAnswer = String(ans);
  processedAnswer = processedAnswer.replace(/\d{4}-\d{2}\b.*$/i, '');
  // Strip year ranges like "2020-21", "2021-22 C Set History" etc. and everything after
  processedAnswer = processedAnswer.replace(/\s*\d{4}-\d{2,4}.*$/i, '');
  
  // Existing cleanup
  processedAnswer = processedAnswer.replace(/\s*\(?[ABC]?-?set\)?/gi, '');
  processedAnswer = processedAnswer.replace(/\s*\(?\d{4}-\d{4}\)?/g, '');
  
  let variants = processedAnswer.split(/\s+or\s+/i).map(v => v.trim()).filter(Boolean);
  const expandedVariants = [];
  variants.forEach(v => {
    if (v.includes('/')) { const slashParts = v.split('/').map(p => p.trim()).filter(Boolean); expandedVariants.push(...slashParts); }
    else expandedVariants.push(v);
  });
  const finalVariants = [];
  expandedVariants.forEach(v => { const commaParts = v.split(',').map(p => p.trim()).filter(Boolean); finalVariants.push(...commaParts); });
  const unique = [...new Set(finalVariants)];
  return unique.length > 1 ? unique : unique[0] || processedAnswer;
}
  
function setFeedback(text, ok=true){
    const f = $('feedback');
    f.textContent = text;
    f.classList.remove('correct','incorrect');
    f.classList.add(ok ? 'correct' : 'incorrect');
    f.style.display = 'block';
    setTimeout(()=>{ f.style.display = 'none'; }, 10000);
}

function clearFeedback(){
    const f = $('feedback');
    f.style.display = 'none';
}

function backToMenu(){
    clearAllTimers();
    updatePauseButtonVisibility();
    $('gameArea').style.display = 'none';
    $('leaderboardPanel').style.display = 'none';
    $('mainMenu').style.display = 'grid';
    $('categorySelection').classList.add('hidden');
    $('showAnswerBtn').style.display = 'inline-block';
    gameState.mode = 'practice';
    $('modeDisplay').textContent = 'Practice';
}

function stripTiebreakerPrefix(text) {
    return text.replace(/^\(TIEBREAKER (BONUS|EXAMPLE) QUESTION\)\s*/i, '');
}

async function openPracticeMode() {
    gameState.mode = 'practice';
    $('modeDisplay').textContent = 'Practice';
    $('mainMenu').style.display = 'none';
    updatePauseButtonVisibility();
    $('gameArea').style.display = 'block';

    const selectedFiles = await promptPracticeSet();
    if (!selectedFiles) { backToMenu(); return; }
    await loadAllQuestionSets(selectedFiles);
    if (!QUESTIONS_SETS.length) { alert("Failed to load selected question sets."); backToMenu(); return; }
    assignPracticeQuestionsFromSets(QUESTIONS_SETS);

    if (promptPracticeQuarter()) {
        resetGame();
        nextQuestion();
    } else {
        backToMenu();
    }
}

function assignPracticeQuestionsFromSets(sets) {
  gameState.activeQ1 = sets.flatMap(set => set.q1 || []);
  gameState.activeQ2 = sets.flatMap(set => set.q2 || []);
  gameState.activeQ3 = sets.flatMap(set => set.q3 || []);
  gameState.activeQ4 = sets.flatMap(set => set.q4 || []);
}

function promptPracticeQuarter() {
    const q1count = gameState.activeQ1 ? gameState.activeQ1.length : 0;
    const q2count = gameState.activeQ2 ? gameState.activeQ2.length : 0;
    const q3count = gameState.activeQ3 ? gameState.activeQ3.length : 0;
    const q4count = gameState.activeQ4 ? gameState.activeQ4.length : 0;
    const promptText = `Enter practice quarter (1,2,3,4) or 'q' to cancel:\nQ1: ${q1count} questions\nQ2: ${q2count*2} questions\nQ3: ${q3count} categories, ${q3count*8} questions\nQ4: ${q4count} questions\nAll: ${q1count+q2count*2+q3count*8+q4count} questions`;
    const choice = prompt(promptText, "1");
    if (!choice || choice.toLowerCase() === 'q') { backToMenu(); return false; }
    const q = parseInt(choice);
    if (![1,2,3,4].includes(q)) { alert("Invalid quarter"); return promptPracticeQuarter(); }
    gameState.currentQuarter = q;
    gameState.practiceQuarterSelected = true;
    gameState.currentQuestionIndex = -1;
    gameState.q3selectedCategory = null;
    gameState.q3categoryProgress = 0;
    return true;
}

function startFullGameFromMenu() {
  if (!gameState.questionsLoaded) { alert("Questions failed to load."); return; }
  gameState.mode = 'full';
  resetGame();
  updatePauseButtonVisibility();
  $('modeDisplay').textContent = 'Full Game';
  $('showAnswerBtn').style.display = 'none';
  $('mainMenu').style.display = 'none';
  $('gameArea').style.display = 'block';
  const letters = parseLetters(FULL_GAME_SET_MODE);
  gameState.activeQ1 = filterByLetters(QUESTIONS.q1 || [], letters);
  gameState.activeQ2 = filterByLetters(QUESTIONS.q2 || [], letters);
  gameState.activeQ3 = filterByLetters(QUESTIONS.q3 || [], letters);
  gameState.activeQ4 = filterByLetters(QUESTIONS.q4 || [], letters);
  startGame();
}

function startPostReadTimer() {
    gameState.postReadTimeLeft = 5;
    $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
    gameState.postReadTimer = setInterval(() => {
        gameState.postReadTimeLeft--;
        $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
        if (gameState.postReadTimeLeft <= 0) {
            clearInterval(gameState.postReadTimer);
            gameState.postReadTimer = null;
            $('buzzerBtn').disabled = true;
            $('timerDisplay').textContent = "Time's up";

            // *** FIX 1: If text is in the answer box, submit it instead of counting wrong ***
            const typedText = $('answerInput').value.trim();
            if (typedText && !$('answerInput').disabled) {
                submitAnswer();
                return;
            }

            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            gameState.questionsAttempted++;
            updateScoreDisplays();
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            if (!gameState.buzzed) {
                const totalBuzzTime = (Date.now() - gameState.questionStartTime) / 1000;
                gameState.buzzInTimes.push(totalBuzzTime);
                updateScoreDisplays();
            }
            scheduleNextQuestion(10000);
        }
    }, 1000);
}

function startAnswerTimer() {
    gameState.answerTimeLeft = 10;
    $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
    gameState.answerTimer = setInterval(() => {
        gameState.answerTimeLeft--;
        $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
        if (gameState.answerTimeLeft <= 0) {
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;

            // *** FIX 1: If text is in the answer box, submit it instead of counting wrong ***
            const typedText = $('answerInput').value.trim();
            if (typedText && !$('answerInput').disabled) {
                submitAnswer();
                return;
            }

            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Time expired";
            setFeedback(`Correct answer: ${formatAnswer(gameState.currentAnswer)}`, false);
            gameState.questionsAttempted++;
            updateScoreDisplays();
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    }, 1000);
}

// *** Helper: schedule nextQuestion, respects pause ***
function scheduleNextQuestion(delay) {
    if (gameState.nextQuestionTimer) {
        clearTimeout(gameState.nextQuestionTimer);
    }
    gameState.nextQuestionDelay = delay;
    gameState.nextQuestionStartTime = Date.now();
    gameState.nextQuestionTimer = setTimeout(() => {
        if (!gameState.isPaused) {
            nextQuestion();
        }
        // If paused, togglePause() resume logic will call nextQuestion via pausedNextQuestionTime
    }, delay);
}

function showLeaderboardPanel(){
    clearAllTimers();
    $('mainMenu').style.display = 'none';
    $('gameArea').style.display = 'none';
    $('leaderboardPanel').style.display = 'block';
    renderGlobalLeaderboard();
}

function clearAllTimers(){
    if (gameState.readingInterval){ clearInterval(gameState.readingInterval); gameState.readingInterval = null; }
    if (gameState.postReadTimer){ clearInterval(gameState.postReadTimer); gameState.postReadTimer = null; }
    if (gameState.answerTimer){ clearInterval(gameState.answerTimer); gameState.answerTimer = null; }
    if (gameState.q3Timer) { clearInterval(gameState.q3Timer); gameState.q3Timer = null; }
    if (gameState.nextQuestionTimer) { clearTimeout(gameState.nextQuestionTimer); gameState.nextQuestionTimer = null; }
    if (gameState.feedbackTimer) { clearInterval(gameState.feedbackTimer); gameState.feedbackTimer = null; }
    if (gameState.bonusTimer) { clearInterval(gameState.bonusTimer); gameState.bonusTimer = null; }
}

function startGame(){
    resetGame();
    gameState.mode = 'full';
    $('modeDisplay').textContent = 'Full Game';
    gameState.currentQuarter = 1;
    gameState.currentQuestionIndex = -1;
    updateScoreDisplays();
    nextQuestion();
}

function togglePause() {
    if (!gameState.isPaused) {
        // PAUSE
        $('answerInput').disabled = true;
        $('submitBtn').disabled = true;
        gameState.wasReading = !!gameState.readingInterval;
        if (gameState.readingInterval) clearInterval(gameState.readingInterval);
        if (gameState.postReadTimer) {
            const val = $('timerDisplay').textContent.match(/Buzz time: ([0-9]+)/);
            gameState.pausedPostReadTime = val ? parseInt(val[1]) : null;
            clearInterval(gameState.postReadTimer);
            gameState.postReadTimer = null;
        }
        if (gameState.answerTimer) {
            const val = $('timerDisplay').textContent.match(/Answer time: ([0-9]+)/);
            gameState.pausedAnswerTime = val ? parseInt(val[1]) : null;
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;
        }
        if (gameState.bonusTimer) {
            gameState.pausedBonusTime = gameState.bonusTimeLeft;
            clearInterval(gameState.bonusTimer);
            gameState.bonusTimer = null;
        }
        if (gameState.q3Timer) {
            gameState.pausedQ3Time = gameState.q3TimeLeft;
            clearInterval(gameState.q3Timer);
            gameState.q3Timer = null;
        }
        // *** FIX 2: Pause the nextQuestion setTimeout ***
        if (gameState.nextQuestionTimer) {
            clearTimeout(gameState.nextQuestionTimer);
            gameState.nextQuestionTimer = null;
            const elapsed = Date.now() - (gameState.nextQuestionStartTime || Date.now());
            gameState.pausedNextQuestionTime = Math.max(0, (gameState.nextQuestionDelay || 0) - elapsed);
        }
        // *** FIX 2: Pause the feedback countdown ***
        if (gameState.feedbackTimer && typeof gameState.feedbackTimeLeft === 'number' && !isNaN(gameState.feedbackTimeLeft) && gameState.feedbackTimeLeft > 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            gameState.pausedFeedbackTime = gameState.feedbackTimeLeft;
        }
        gameState.isPaused = true;
        $('pauseBtn').textContent = "Resume";
        setFeedback("Paused. Press Resume to continue.", true);
        $('buzzerBtn').disabled = true;
        $('showAnswerBtn').disabled = true;
        if (gameState.buzzed || (gameState.currentQuarter === 3 && gameState.q3CategoryActive) || gameState.isAnsweringBonus) {
            $('answerInput').disabled = false;
        } else {
            $('answerInput').disabled = true;
        }
    } else {
        // RESUME
        gameState.isPaused = false;
        $('pauseBtn').textContent = "Pause";
        clearFeedback();
        
        if (gameState.wasReading) resumeReading();
        if (typeof gameState.pausedPostReadTime === 'number' && gameState.pausedPostReadTime > 0) {
            gameState.postReadTimeLeft = gameState.pausedPostReadTime;
            resumePostReadTimer();
        }
        if (typeof gameState.pausedAnswerTime === 'number' && gameState.pausedAnswerTime > 0) {
            gameState.answerTimeLeft = gameState.pausedAnswerTime;
            resumeAnswerTimer();
        }
        if (typeof gameState.pausedBonusTime === 'number' && gameState.pausedBonusTime > 0) {
            gameState.bonusTimeLeft = gameState.pausedBonusTime;
            resumeBonusTimer();
        }
        if (gameState.currentQuarter === 3 && gameState.q3CategoryActive && typeof gameState.pausedQ3Time === 'number') {
            gameState.q3TimeLeft = gameState.pausedQ3Time;
            startQ3CategoryTimer();
        }

        // *** FIX 2: Resume the nextQuestion timer from remaining time ***
        if (gameState.pausedNextQuestionTime !== null && gameState.pausedNextQuestionTime >= 0) {
            const remaining = gameState.pausedNextQuestionTime;
            gameState.nextQuestionDelay = remaining;
            gameState.nextQuestionStartTime = Date.now();
            gameState.nextQuestionTimer = setTimeout(() => {
                if (!gameState.isPaused) nextQuestion();
            }, remaining);
        }

        // *** FIX 2: Resume the feedback countdown from remaining time ***
        if (typeof gameState.pausedFeedbackTime === 'number' && !isNaN(gameState.pausedFeedbackTime) && gameState.pausedFeedbackTime > 0) {
            resumeFeedbackCountdown(gameState.pausedFeedbackTime);
            gameState.pausedFeedbackTime = null;
        }

        gameState.pausedPostReadTime = null;
        gameState.pausedAnswerTime = null;
        gameState.pausedBonusTime = null;
        gameState.pausedQ3Time = null;
        gameState.pausedNextQuestionTime = null;
        gameState.wasReading = false;

        if (gameState.buzzed || (gameState.currentQuarter === 3 && gameState.q3CategoryActive) || gameState.isAnsweringBonus) {
            $('buzzerBtn').disabled = true;
        } else {
            $('buzzerBtn').disabled = false;
        }
        $('showAnswerBtn').disabled = gameState.isShowingAnswer ? true : false;
        if (gameState.buzzed || (gameState.currentQuarter === 3 && gameState.q3CategoryActive) || gameState.isAnsweringBonus) {
            $('answerInput').disabled = false;
        } else {
            $('answerInput').disabled = true;
        }
        $('submitBtn').disabled = $('answerInput').disabled;
    }
}

function resumeBonusTimer() {
    $('timerDisplay').textContent = `Bonus time: ${gameState.bonusTimeLeft}`;
    gameState.bonusTimer = setInterval(() => {
        gameState.bonusTimeLeft--;
        $('timerDisplay').textContent = `Bonus time: ${gameState.bonusTimeLeft}`;
        if (gameState.bonusTimeLeft <= 0) {
            clearInterval(gameState.bonusTimer);
            gameState.bonusTimer = null;
            const typedText = $('answerInput').value.trim();
            if (typedText && !$('answerInput').disabled) { submitAnswer(); return; }
            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Bonus expired";
            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentBonus?.question || '';
            gameState.currentBonus = null;
            gameState.isAnsweringBonus = false;
            scheduleNextQuestion(10000);
        }
    }, 1000);
}
  
function resumeFeedbackCountdown(timeLeft) {
    if (typeof timeLeft !== 'number' || isNaN(timeLeft) || timeLeft <= 0) { nextQuestion(); return; }
    if (gameState.feedbackTimer) clearInterval(gameState.feedbackTimer);
    gameState.feedbackTimeLeft = timeLeft;
    $('timerDisplay').textContent = `Next question in: ${timeLeft}`;
    gameState.feedbackTimer = setInterval(() => {
        timeLeft--;
        gameState.feedbackTimeLeft = timeLeft;
        $('timerDisplay').textContent = `Next question in: ${timeLeft}`;
        if (timeLeft <= 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            $('timerDisplay').textContent = '--';
            nextQuestion();
        }
    }, 1000);
}

function resumeReading() {
    const questionText = gameState.currentQuestionText;
    const idx = gameState.readingCharIndex;
    $('questionText').textContent = questionText.slice(0, idx);
    gameState.readingInterval = setInterval(() => {
        if (gameState.readingCharIndex < questionText.length && !gameState.buzzed) {
            $('questionText').textContent += questionText[gameState.readingCharIndex];
            gameState.readingCharIndex++;
        } else {
            clearInterval(gameState.readingInterval);
            gameState.readingInterval = null;
            startPostReadTimer();
        }
    }, 30);
}

function resumePostReadTimer() {
    $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
    gameState.postReadTimer = setInterval(() => {
        gameState.postReadTimeLeft--;
        $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
        if (gameState.postReadTimeLeft <= 0) {
            clearInterval(gameState.postReadTimer);
            gameState.postReadTimer = null;
            $('buzzerBtn').disabled = true;
            $('timerDisplay').textContent = "Time's up";
            const typedText = $('answerInput').value.trim();
            if (typedText && !$('answerInput').disabled) { submitAnswer(); return; }
            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            gameState.questionsAttempted++;
            updateScoreDisplays();
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    }, 1000);
}

function resumeAnswerTimer() {
    $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
    gameState.answerTimer = setInterval(() => {
        gameState.answerTimeLeft--;
        $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
        if (gameState.answerTimeLeft <= 0) {
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;
            const typedText = $('answerInput').value.trim();
            if (typedText && !$('answerInput').disabled) { submitAnswer(); return; }
            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Time expired";
            setFeedback(`Correct answer: ${formatAnswer(gameState.currentAnswer)}`, false);
            gameState.questionsAttempted++;
            updateScoreDisplays();
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    }, 1000);
}

function updatePauseButtonVisibility() {
    $('pauseBtn').style.display = (gameState.mode === 'practice' || gameState.mode === 'missed') ? 'inline-block' : 'none';
}

function resetGame() {
    clearAllTimers();
    gameState._pdfAddedKeys = new Set();
    gameState = {
        ...gameState,
        currentQuarter: gameState.currentQuarter,
        currentQuestionIndex: -1,
        rawScore: 0,
        weightedScore: 0,
        responseTimes: [],
        readingInterval: null,
        postReadTimer: null,
        answerTimer: null,
        pausedPostReadTime: null,
        bonusTimer: null,
        bonusTimeLeft: null,
        questionsAttempted: 0,
        questionsCorrect: 0,
        pausedAnswerTime: null,
        wasReading: false,
        readingCharIndex: 0,
        currentQuestionText: "",
        currentAnswer: "",
        currentBonus: null,
        buzzed: false,
        buzzInTimes: [],
        isPaused: false,
        savedIntervals: {},
        multiplier: 1,
        q3SelectedCategoryData: null,
        q3DisplayedCategories: null,
        q3categoryProgress: 0,
        q3categoryCorrectCount: 0,
        q3Swept: false,
        lastActionTimestamp: null,
        questionStartTime: null,
        buzzTime: null,
        practiceQuarterSelected: false,
        feedbackTimer: null,
        feedbackTimeLeft: null,
        pausedFeedbackTime: null,
        nextQuestionTimer: null,
        nextQuestionDelay: null,
        pausedNextQuestionTime: null,
        nextQuestionStartTime: null
    };

    if (gameState.mode === 'full') {
        gameState.activeQ1 = shuffle([...QUESTIONS.q1]).slice(0, 10);
        gameState.activeQ2 = shuffle([...QUESTIONS.q2]).slice(0, 8);
        gameState.activeQ4 = shuffle([...QUESTIONS.q4]).slice(0, 8);
        gameState.activeQ3 = shuffle([...QUESTIONS.q3]);
    } else {
        // Practice: apply mastered filter
        if (Array.isArray(gameState.activeQ1)) gameState.activeQ1 = shuffle(filterMasteredQ1([...gameState.activeQ1]));
        if (Array.isArray(gameState.activeQ2)) gameState.activeQ2 = shuffle(filterMasteredQ2([...gameState.activeQ2]));
        if (Array.isArray(gameState.activeQ3)) gameState.activeQ3 = shuffle([...gameState.activeQ3]);
        if (Array.isArray(gameState.activeQ4)) gameState.activeQ4 = shuffle(filterMasteredQ4([...gameState.activeQ4]));

        // Check if all mastered for the current quarter
        if (gameState.mode === 'practice') {
            const quarter = gameState.currentQuarter;
            const arr = quarter === 1 ? gameState.activeQ1 : quarter === 2 ? gameState.activeQ2 : quarter === 4 ? gameState.activeQ4 : null;
            if (arr !== null && arr.length === 0) {
                // All mastered ‚Äî show modal after a brief delay so UI renders first
                setTimeout(() => showMasteredModal(quarter), 300);
            }
        }
    }

    $('questionText').textContent = gameState.questionsLoaded ?
        "Select a category to start!" :
        "Questions are loading / Failed to load.";
    $('buzzerBtn').disabled = true;
    $('answerInput').disabled = true;
    $('categorySelection').classList.add('hidden');
    $('answerInput').value = '';
    $('currentResponseTime').textContent = 'Response time: --';
    $('questionCounter').textContent = 'Q 0 / 0';
    $('timerDisplay').textContent = '--';
    updateScoreDisplays();
    clearFeedback();
}

if (!gameState._pdfAddedKeys) gameState._pdfAddedKeys = new Set();

async function resetPracticeGame() {
    if (gameState.mode === 'full') {
        startFullGameFromMenu();
    } else {
        gameState.mode = 'practice';
        $('modeDisplay').textContent = 'Practice';
        $('mainMenu').style.display = 'none';
        $('gameArea').style.display = 'block';
        const selectedFiles = await promptPracticeSet();
        if (!selectedFiles) { backToMenu(); return; }
        await loadAllQuestionSets(selectedFiles);
        if (!QUESTIONS_SETS.length) { alert("Failed to load selected question sets."); backToMenu(); return; }
        assignPracticeQuestionsFromSets(QUESTIONS_SETS);
        if (promptPracticeQuarter()) {
            resetGame();
            updatePauseButtonVisibility();
            nextQuestion();
        } else {
            backToMenu();
        }
    }
}

function shuffle(array){
    for (let i = array.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i+1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function getCurrentQuarterArray(){
    if (gameState.currentQuarter === 1) return gameState.activeQ1;
    if (gameState.currentQuarter === 2) return gameState.activeQ2;
    if (gameState.currentQuarter === 3) return gameState.activeQ3;
    if (gameState.currentQuarter === 4) return gameState.activeQ4;
    return [];
}

function nextQuestion() {
  addCurrentQuestionToPDF();
  if (!gameState.questionsLoaded) { alert("Questions failed to load."); return; }
  clearAllTimers();
  if (gameState.currentQuarter !== 3) { $('q3PrefixBox').classList.add('hidden'); $('q3PrefixBox').textContent = ''; }
  clearFeedback();
  $('showAnswerBtn').disabled = false;
  gameState.isShowingAnswer = false;

  if (gameState.currentQuarter === 3) {
    if (gameState.q3selectedCategory === null) { showCategorySelection(); return; }
    if (gameState.mode === 'full') QUESTIONS.q3 = gameState.activeQ3;
    const cat = gameState.activeQ3[gameState.q3selectedCategory];
    if (!cat || !cat.questions || cat.questions.length === 0) { $('questionText').textContent = "No questions in this category."; return; }
    if (gameState.q3categoryProgress >= cat.questions.length) {
      if (gameState.mode === 'full') { gameState.currentQuarter++; gameState.currentQuestionIndex = -1; gameState.q3selectedCategory = null; gameState.q3categoryProgress = 0; nextQuestion(); return; }
      else { gameState.q3selectedCategory = null; showCategorySelection(); return; }
    }
    showQ3CategoryQuestion();
    return;
  }

  if (gameState.currentQuarter === 1) {
    gameState.currentQuestionIndex++;

    // *** FIX 3: Check if we ran out after mastered filter ***
    if (gameState.currentQuestionIndex >= (gameState.activeQ1?.length || 0)) {
      if (gameState.mode === 'full') { gameState.currentQuarter++; gameState.currentQuestionIndex = -1; nextQuestion(); return; }
      else {
        // Reload with mastered filter
        const fresh = filterMasteredQ1(QUESTIONS_SETS.flatMap(s => s.q1 || []));
        if (fresh.length === 0) { showMasteredModal(1); return; }
        alert(`No more questions in Quarter 1.`);
        gameState.currentQuestionIndex = (gameState.activeQ1?.length || 1) - 1;
        return;
      }
    }
  } else if (gameState.currentQuarter === 2) {
    if (!gameState.isAnsweringBonus) gameState.currentQuestionIndex++;
    if (gameState.currentQuestionIndex >= (gameState.activeQ2?.length || 0)) {
      if (gameState.mode === 'full') { gameState.currentQuarter++; gameState.currentQuestionIndex = -1; nextQuestion(); return; }
      else {
        const fresh = filterMasteredQ2(QUESTIONS_SETS.flatMap(s => s.q2 || []));
        if (fresh.length === 0) { showMasteredModal(2); return; }
        alert(`No more questions in Quarter 2.`);
        gameState.currentQuestionIndex = (gameState.activeQ2?.length || 1) - 1;
        return;
      }
    }
  } else if (gameState.currentQuarter === 4) {
    gameState.currentQuestionIndex++;
    if (gameState.currentQuestionIndex >= (gameState.activeQ4?.length || 0)) {
      if (gameState.mode === 'full') { finishGame(); return; }
      else {
        const fresh = filterMasteredQ4(QUESTIONS_SETS.flatMap(s => s.q4 || []));
        if (fresh.length === 0) { showMasteredModal(4); return; }
        alert(`No more questions in Quarter 4.`);
        gameState.currentQuestionIndex = (gameState.activeQ4?.length || 1) - 1;
        return;
      }
    }
  }

  $('buzzerBtn').disabled = true;
  $('answerInput').disabled = true;
  $('answerInput').value = '';
  $('questionText').textContent = 'Get ready...';
  $('questionCounter').textContent = computeQuestionCounterText();
  $('currentResponseTime').textContent = 'Response time: --';
  $('categorySelection').classList.add('hidden');

  setTimeout(() => startReading(), 800);
}

function showCategorySelection(){
    const container = $('categorySelection');
    container.innerHTML = `<h4 style="width:100%">Select a Category</h4>`;
    container.classList.remove('hidden');
    let categories = gameState.activeQ3;
    if (!categories || !Array.isArray(categories) || categories.length === 0) {
        container.innerHTML = '<h4 style="width:100%">No categories available</h4>';
        return;
    }
    let selected = weightedPickCategories(categories, practiceCategoryWeights);
    gameState.q3DisplayedCategories = selected;
    selected.forEach((cat, idx) => {
        const btn = document.createElement('div');
        btn.className = 'category-btn';
        btn.textContent = cat.category;
        btn.onclick = () => { container.classList.add('hidden'); selectCategory(idx); };
        container.appendChild(btn);
    });
}
  
function selectCategory(displayIdx) {
    const categoryData = gameState.q3DisplayedCategories[displayIdx];
    gameState.q3SelectedCategoryData = categoryData;
    gameState.q3categoryProgress = 0;
    gameState.q3categoryCorrectCount = 0;
    if (!categoryData || !categoryData.questions) { console.error("Invalid category data:", categoryData); return; }
    gameState.q3CategoryQuestions = categoryData.questions.map(q => ({ ...q, userAnswer: "", isCorrect: false }));
    gameState.q3CurrentQuestionIdx = 0;
    gameState.q3TimeLeft = 60;
    gameState.q3CategoryActive = true;
    $('categorySelection').classList.add('hidden');
    const prefix = categoryData.prompt || "Millard Fillmore is or was...";
    $('q3PrefixBox').textContent = prefix;
    $('q3PrefixBox').classList.remove('hidden');
    $('questionText').textContent = prefix;
    $('answerInput').disabled = true;
    $('buzzerBtn').disabled = true;
    $('showAnswerBtn').disabled = true;
    setTimeout(() => { startQ3CategoryTimer(); showQ3CategoryQuestion(); }, 2000);
}

function startQ3CategoryTimer() {
    $('timerDisplay').textContent = `Time left: ${gameState.q3TimeLeft}s`;
    gameState.q3Timer = setInterval(() => {
        gameState.q3TimeLeft--;
        $('timerDisplay').textContent = `Time left: ${gameState.q3TimeLeft}s`;
        if (gameState.q3TimeLeft <= 0) { finalizeCurrentQ3InputOnTimeout(); }
    }, 1000);
}

function stopQ3CategoryTimer() {
    if (gameState.q3Timer) { clearInterval(gameState.q3Timer); gameState.q3Timer = null; }
}

function finalizeCurrentQ3InputOnTimeout() {
  const qArr = gameState.q3CategoryQuestions || [];
  const idx = gameState.q3CurrentQuestionIdx ?? 0;
  const curr = qArr[idx];
  if (curr && !curr.userAnswer) {
    const typed = $('answerInput').value.trim();
    if (typed) {
      curr.userAnswer = typed;
      const correct = isStrictCorrect(typed, curr.answer) || looseMatch(typed, curr.answer);
      curr.isCorrect = correct;
      if (correct) {
        const earnedPoints = 10;
        gameState.rawScore += earnedPoints;
        const wInc = computeWeightedIncrement(earnedPoints, { isQ3: true });
        gameState.weightedScore = (gameState.weightedScore || 0) + wInc;
      }
      gameState.questionsAttempted++;
      if (correct) gameState.questionsCorrect++;
      updateScoreDisplays();
    }
  }
  finishQ3CategoryRound();
}

function finishQ3CategoryRound() {
    const qArr = gameState.q3CategoryQuestions;
    stopQ3CategoryTimer();
    gameState.q3CategoryActive = false;
    $('q3PrefixBox').classList.add('hidden');
    $('q3PrefixBox').textContent = "";
    $('answerInput').disabled = true;
    $('buzzerBtn').disabled = true;
    if ($('skipBtn')) $('skipBtn').remove();
    const correct = gameState.q3CategoryQuestions.filter(q => q.isCorrect).length;
    const points = correct * 10;
    let resultHtml = `<strong>Category complete!</strong><br>You got <strong>${correct}/${qArr.length}</strong> correct (+${points} pts).<br><br>`;
    resultHtml += `<table style="width:100%;text-align:left;font-size:0.98em;background:#fff;"><thead><tr><th>#</th><th>Question</th><th>Your Answer</th><th>Correct Answer</th><th>‚úì</th></tr></thead><tbody>`;
    qArr.forEach((q, i) => {
        resultHtml += `<tr><td>${i+1}</td><td>${q.question}</td><td>${q.userAnswer || "---"}</td><td>${formatAnswer(q.answer)}</td><td style="color:${q.isCorrect ? '#38a169':'#e53e3e'};">${q.isCorrect ? '‚úîÔ∏è':'‚ùå'}</td></tr>`;
    });
    resultHtml += `</tbody></table>`;
    $('questionText').innerHTML = resultHtml;
    updateScoreDisplays();
    setFeedback(`Category complete! ${correct} correct, +${points} pts.`, true);
    startFeedbackCountdown(20);
    scheduleNextQuestion(20000);
}

function calculateAverageBuzzInTime() {
    if (!gameState.buzzInTimes.length) return null;
    const sum = gameState.buzzInTimes.reduce((a, b) => a + b, 0);
    return sum / gameState.buzzInTimes.length;
}

function showQ3CategoryQuestion() {
    const qArr = gameState.q3CategoryQuestions;
    if (document.getElementById('skipBtn')) document.getElementById('skipBtn').remove();
    const cat = gameState.q3SelectedCategoryData;
    if (!cat) { console.error("No selected category data available"); return; }
    const prefix = cat.prompt || "Millard Fillmore is or was...";
    $('q3PrefixBox').textContent = prefix;
    $('q3PrefixBox').classList.remove('hidden');
    let idx = gameState.q3CurrentQuestionIdx;
    let cnt = 0;
    while (qArr[idx] && qArr[idx].userAnswer && cnt < qArr.length) { idx = (idx + 1) % qArr.length; cnt++; }
    if (cnt >= qArr.length || !qArr[idx]) { finishQ3CategoryRound(); return; }
    gameState.q3CurrentQuestionIdx = idx;
    gameState.questionStartTime = Date.now();
    $('questionCounter').textContent = computeQuestionCounterText();
    $('questionText').textContent = `(${idx + 1}/${qArr.length}) ${qArr[idx].question}`;
    $('answerInput').disabled = false;
    $('answerInput').value = '';
    $('answerInput').focus();
    $('buzzerBtn').disabled = true;
    $('showAnswerBtn').disabled = true;
    if (!document.getElementById('skipBtn')) {
        const skipBtn = document.createElement('button');
        skipBtn.id = 'skipBtn';
        skipBtn.className = 'btn secondary';
        skipBtn.textContent = 'Skip';
        skipBtn.onclick = () => {
            const qArr = gameState.q3CategoryQuestions;
            let idx = gameState.q3CurrentQuestionIdx;
            if (!qArr[idx].userAnswer) { qArr[idx].userAnswer = "---"; qArr[idx].isCorrect = false; }
            let nextIdx = (idx + 1) % qArr.length;
            let cnt = 0;
            while (qArr[nextIdx].userAnswer && cnt < qArr.length) { nextIdx = (nextIdx + 1) % qArr.length; cnt++; }
            if (!qArr.some(q => !q.userAnswer)) finishQ3CategoryRound();
            else { gameState.q3CurrentQuestionIdx = nextIdx; showQ3CategoryQuestion(); }
        };
        $('answerInput').parentNode.insertBefore(skipBtn, $('answerInput').nextSibling);
    }
}

function startReading(){
    gameState.questionStartTime = Date.now();
    $('buzzerBtn').disabled = false;
    clearAllTimers();
    gameState.buzzed = false;
    gameState.multiplier = 1;
    updateScoreDisplays();
    clearFeedback();

    let questionText = "";
    let correctAnswer = "";
    gameState.currentBonus = null;

    if (gameState.currentQuarter === 1){
        const q = gameState.activeQ1[gameState.currentQuestionIndex];
        questionText = q ? q.question : "";
        correctAnswer = q ? preprocessAnswer(q.answer) : "";
    } else if (gameState.currentQuarter === 2){
        const q = gameState.activeQ2[gameState.currentQuestionIndex];
        questionText = q ? q.tossup.question : "";
        correctAnswer = q ? preprocessAnswer(q.tossup.answer) : "";
        gameState.currentBonus = q ? q.bonus : null;
    } else if (gameState.currentQuarter === 3){
        const cat = gameState.activeQ3[gameState.q3selectedCategory];
        const qIndex = gameState.q3categoryProgress;
        const q = cat && cat.questions ? cat.questions[qIndex] : null;
        questionText = q ? q.question : "";
        correctAnswer = q ? preprocessAnswer(q.answer) : "";
    } else if (gameState.currentQuarter === 4){
        const q = gameState.activeQ4[gameState.currentQuestionIndex];
        if (!q){ questionText = ""; correctAnswer = ""; }
        else {
            gameState.currentQ4Parts = q.parts;
            questionText = q.parts.join(" ");
            correctAnswer = preprocessAnswer(q.answer);
            let boundaries = [];
            let idx = 0;
            q.parts.forEach((part, i) => { boundaries.push({ part: i, start: idx, end: idx + part.length }); idx += part.length + 1; });
            gameState.q4PartBoundaries = boundaries;
        }
    }

    if (!questionText) { $('questionText').textContent = "No question available."; return; }

    gameState.currentQuestionText = questionText;
    gameState.currentAnswer = correctAnswer;
    gameState.readingCharIndex = 0;
    $('questionText').textContent = "";
    $('timerDisplay').textContent = "--";

    gameState.readingInterval = setInterval(async ()=>{
        if (gameState.readingCharIndex < questionText.length && !gameState.buzzed){
            $('questionText').textContent += questionText[gameState.readingCharIndex];
            gameState.readingCharIndex++;
            if (gameState.currentQuarter === 4) {
                let idx = gameState.readingCharIndex;
                let boundaries = gameState.q4PartBoundaries;
                let partIndex = boundaries.length - 1;
                for (let i = 0; i < boundaries.length; i++) { if (idx < boundaries[i].end) { partIndex = i; break; } }
                gameState.q4CurrentPart = partIndex;
            }
        } else {
            clearInterval(gameState.readingInterval);
            gameState.readingInterval = null;
            if (!gameState.buzzed){
                let postReadTime = 5;
                $('timerDisplay').textContent = `Buzz time: ${postReadTime}`;
                gameState.postReadTimeLeft = postReadTime;
                gameState.postReadTimer = setInterval(async ()=>{
                    postReadTime--;
                    gameState.postReadTimeLeft = postReadTime;
                    $('timerDisplay').textContent = `Buzz time: ${postReadTime}`;
                    if (postReadTime <= 0){
                        clearInterval(gameState.postReadTimer);
                        gameState.postReadTimer = null;
                        $('buzzerBtn').disabled = true;
                        $('timerDisplay').textContent = "Time's up";

                        // *** FIX 1: submit if text in box ***
                        const typedText = $('answerInput').value.trim();
                        if (typedText && !$('answerInput').disabled) {
                            submitAnswer();
                            return;
                        }

                        gameState.questionsAttempted++;
                        updateScoreDisplays();
                        const nodeAnswer = findNodeAnswer(gameState.currentAnswer);
                        if (nodeAnswer) syncKnowledgeGraphProgress(nodeAnswer, false);
                        setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
                        startFeedbackCountdown(10);
                        $('questionText').textContent = gameState.currentQuestionText;
                        if (!gameState.buzzed) {
                            const totalBuzzTime = (Date.now() - gameState.questionStartTime) / 1000;
                            gameState.buzzInTimes.push(totalBuzzTime);
                            updateScoreDisplays();
                        }
                        scheduleNextQuestion(10000);
                    }
                }, 1000);
            }
        }
    }, 45);
}

function buzz(){
    if (gameState.buzzed) return;
    gameState.buzzed = true;
    gameState.buzzTime = Date.now();
    clearAllTimers();
    $('showAnswerBtn').disabled = true;
    if (gameState.questionStartTime && gameState.buzzTime) {
        const buzzInTime = (gameState.buzzTime - gameState.questionStartTime) / 1000;
        gameState.buzzInTimes.push(buzzInTime);
    }
    let pctRead = 1;
    if (gameState.currentQuestionText && gameState.readingCharIndex){
        pctRead = gameState.readingCharIndex / gameState.currentQuestionText.length;
        if (pctRead < 0) pctRead = 0;
        if (pctRead > 1) pctRead = 1;
    }
    if (pctRead < 0.15) gameState.multiplier = 5;
    else if (pctRead < 0.35) gameState.multiplier = 4;
    else if (pctRead < 0.55) gameState.multiplier = 3;
    else if (pctRead < 0.8) gameState.multiplier = 2;
    else gameState.multiplier = 1;
    if (gameState.currentQuarter === 4) {
        let bracketPoints = 10;
        if (gameState.q4CurrentPart === 0) bracketPoints = 30;
        else if (gameState.q4CurrentPart === 1) bracketPoints = 20;
        else bracketPoints = 10;
        gameState.q4BracketPoints = bracketPoints;
    } else {
        gameState.q4BracketPoints = 10;
    }
    $('answerInput').disabled = false;
    $('showAnswerBtn').disabled = true;
    $('answerInput').focus();
    $('buzzerBtn').disabled = true;
    updateScoreDisplays();
    gameState.answerTimeLeft = 10;
    $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
    gameState.answerTimer = setInterval(async ()=>{
        gameState.answerTimeLeft--;
        $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
        if (gameState.answerTimeLeft <= 0){
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;
            // *** FIX 1: submit if text in box ***
            const typedText = $('answerInput').value.trim();
            if (typedText && !$('answerInput').disabled) { submitAnswer(); return; }
            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Time expired";
            gameState.questionsAttempted++;
            updateScoreDisplays();
            const nodeAnswer = findNodeAnswer(gameState.currentAnswer);
            if (nodeAnswer) syncKnowledgeGraphProgress(nodeAnswer, false);
            setFeedback(`Correct answer: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    }, 1000);
}

function showAnswer(){
    if (gameState.isShowingAnswer) return;
    gameState.isShowingAnswer = true;
    clearAllTimers();
    setFeedback(`Answer: ${formatAnswer(gameState.currentAnswer)}`, true);
    $('questionText').textContent = gameState.currentQuestionText || '---';
    $('buzzerBtn').disabled = true;
    $('answerInput').disabled = true;
    $('answerInput').value = '';
    $('showAnswerBtn').disabled = true;
    let secs = 10;
    $('timerDisplay').textContent = `Next question in: ${secs}`;
    gameState.feedbackTimeLeft = secs;
    gameState.feedbackTimer = setInterval(() => {
        secs--;
        gameState.feedbackTimeLeft = secs;
        $('timerDisplay').textContent = `Next question in: ${secs}`;
        if (secs <= 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            $('timerDisplay').textContent = '--';
            gameState.isShowingAnswer = false;
            nextQuestion();
        }
    }, 1000);
}

function removeDiacritics(str) {
  if (!str) return '';
  return String(str).normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[\u0080-\u024F]/g, (char) => {
    const replacements = {'√ü':'ss','√¶':'ae','≈ì':'oe','√∏':'o','√∞':'d','√æ':'th','¬¥':'','`':'','ÀÜ':'','¬®':'','Àú':'','¬∏':''};
    return replacements[char] || char;
  });
}

function normalizeForMatching(text) {
  return removeDiacritics(text).toLowerCase().replace(/[¬¥`ÀÜ¬®Àú¬∏'']/g, '').replace(/\s+/g, ' ').trim();
}

function normalize(s){ return normalizeForMatching((s || "").toString().trim()); }

function normalizeText(s) {
  if (s == null) return '';
  return String(s).toLowerCase().replace(/\s+/g, ' ').replace(/[^\S\r\n]/g, ' ').trim();
}

function ensureUniquePDFAdd(quarter, payload, questionTextForKey, answerForKey) {
  const ansText = typeof formatAnswer === 'function' ? formatAnswer(answerForKey) : (Array.isArray(answerForKey) ? answerForKey.join(', ') : String(answerForKey ?? ''));
  const key = pdfKeyFor(quarter, questionTextForKey, ansText);
  if (!gameState._pdfAddedKeys) gameState._pdfAddedKeys = new Set();
  if (gameState._pdfAddedKeys.has(key)) return false;
  const buckets = gameState.pdfQuestions || (gameState.pdfQuestions = { q1:[], q2:[], q3:[], q4:[] });
  const map = {1:'q1', 2:'q2', 3:'q3', 4:'q4', '1':'q1', '2':'q2', '3':'q3', '4':'q4'};
  const bucket = buckets[ map[quarter] ];
  if (!bucket) return false;
  bucket.push(payload);
  gameState._pdfAddedKeys.add(key);
  return true;
}

function pdfKeyFor(quarter, questionText, answerText) {
  return `${quarter}|${normalizeText(questionText)}|${normalizeText(answerText)}`;
}

function getPluralForms(word) {
    let forms = [word];
    if (word.endsWith('y') && word.length > 2) forms.push(word.slice(0, -1) + 'ies');
    if (word.endsWith('ies') && word.length > 3) forms.push(word.slice(0, -3) + 'y');
    if (word.endsWith('s') && word.length > 2) forms.push(word.slice(0, -1));
    else forms.push(word + 's');
    if (!word.endsWith('es')) forms.push(word + 'es');
    if (word.endsWith('es') && word.length > 2) forms.push(word.slice(0, -2));
    return Array.from(new Set(forms));
}

function isStrictCorrect(given, answer) {
    const normGiven = normalize(given);
    if (Array.isArray(answer)) {
        return answer.some(a => {
            const normA = normalize(a);
            if (normA === "saint valentine" || normA === "st valentine") return normGiven === "saint valentine" || normGiven === "st valentine" || normGiven === "valentine";
            if (normA === "joint-stock company" || normA === "joint stock company") return normGiven === "joint-stock company" || normGiven === "joint stock company";
            return normA === normGiven;
        });
    } else {
        const normA = normalize(answer);
        if (normA === "saint valentine" || normA === "st valentine") return normGiven === "saint valentine" || normGiven === "st valentine" || normGiven === "valentine";
        if (normA === "joint-stock company" || normA === "joint stock company") return normGiven === "joint-stock company" || normGiven === "joint stock company";
        return normA === normGiven;
    }
}

function normalizeAnswerArray(ans) {
    if (Array.isArray(ans)) return ans.map(a => a.trim().toLowerCase());
    return ans.split(',').map(a => a.trim().toLowerCase());
}

function findNodeAnswer(correctAnswer) {
  if (!knowledgeGraphNodes || knowledgeGraphNodes.length === 0) return null;
  let answerToMatch = correctAnswer;
  if (Array.isArray(correctAnswer)) answerToMatch = correctAnswer[0];
  answerToMatch = String(answerToMatch || '');
  const variations = answerToMatch.split(',').map(v => v.trim().toLowerCase());
  for (const variant of variations) {
    let match = knowledgeGraphNodes.find(node => normalizeAnswer(node.answer).toLowerCase() === variant);
    if (match) return match.answer;
    match = knowledgeGraphNodes.find(node => { const nodeVariations = node.answer.split(',').map(v => v.trim().toLowerCase()); return nodeVariations.includes(variant); });
    if (match) return match.answer;
    match = knowledgeGraphNodes.find(node => { const nodeAnswerLower = normalizeAnswer(node.answer).toLowerCase(); return nodeAnswerLower.includes(variant) || variant.includes(nodeAnswerLower); });
    if (match) return match.answer;
  }
  return null;
}

async function syncWithKnowledgeGraph(userAnswer, isCorrect) {
  const nodeAnswer = findNodeAnswer(userAnswer);
  if (!nodeAnswer) return;
  const normalizedKey = normalizeAnswer(nodeAnswer);
  let progress = userProgress[normalizedKey];
  if (Array.isArray(progress)) { progress = { stars: progress[0] || 0, lastReviewed: progress[1] || Date.now(), times_correct: 0, times_wrong: 0 }; }
  else if (!progress) { progress = { stars: 0, lastReviewed: Date.now(), times_correct: 0, times_wrong: 0 }; }
  if (isCorrect) { progress.times_correct = (progress.times_correct || 0) + 1; if (progress.stars === 1) progress.stars = 2; }
  else { progress.times_wrong = (progress.times_wrong || 0) + 1; }
  progress.lastReviewed = Date.now();
  userProgress[normalizedKey] = progress;
  await saveUserProgress();
}

let userProgress = {};

async function startMissedQuestionsMode() {
  if (!currentUser) { alert('Please login first to access missed questions.'); showLoginModal(); return; }
  await loadMissedQuestions();
  if (missedQuestions.length === 0) { alert('No missed questions yet! Play some games first.'); return; }
  gameState.mode = 'missed';
  gameState.currentQuarter = 1;
  gameState.activeQ1 = missedQuestions.map(mq => ({ question: mq.question, answer: mq.answer }));
  gameState.activeQ2 = [];
  gameState.activeQ3 = [];
  gameState.activeQ4 = [];
  $('mainMenu').style.display = 'none';
  $('gameArea').style.display = 'block';
  $('modeDisplay').textContent = 'Missed Questions Review';
  $('showAnswerBtn').style.display = 'inline-block';
  updatePauseButtonVisibility();
  resetGame();
  nextQuestion();
}
  
async function submitAnswer(){
    if (gameState.isPaused) return;
    if ($('answerInput').disabled) return;
    if(gameState.bonusTimer) { clearInterval(gameState.bonusTimer); gameState.bonusTimer = null; }
    const given = $('answerInput').value.trim();
    if (!given){ setFeedback("Please type an answer before submitting.", false); return; }

    const isCorrect = isStrictCorrect(given, gameState.currentAnswer) || looseMatch(given, gameState.currentAnswer);
    const nodeAnswer = findNodeAnswer(gameState.currentAnswer);
    if (nodeAnswer) await syncKnowledgeGraphProgress(nodeAnswer, isCorrect);
    let basePoints = 0;
    let earnedPoints = 0;
    const submitTime = Date.now();
    let responseTime = null;
    if (gameState.currentQuarter === 3 && gameState.q3CategoryActive) {
        responseTime = (submitTime - gameState.questionStartTime) / 1000;
    } else if (gameState.buzzTime) {
        responseTime = (submitTime - gameState.buzzTime) / 1000;
    }
    if (responseTime !== null) $('currentResponseTime').textContent = `Response time: ${responseTime.toFixed(1)}s`;

    // Quarter 3
    if (gameState.currentQuarter === 3 && gameState.q3CategoryActive) {
        const idx = gameState.q3CurrentQuestionIdx;
        const qArr = gameState.q3CategoryQuestions;
        qArr[idx].userAnswer = given;
        const correct = isStrictCorrect(given, preprocessAnswer(qArr[idx].answer)) || looseMatch(given, preprocessAnswer(qArr[idx].answer));
        qArr[idx].isCorrect = correct;
        gameState.questionsAttempted++;
        if (correct) gameState.questionsCorrect++;
        updateScoreDisplays();
        if (correct) {
            const earnedPoints = 10;
            gameState.rawScore += earnedPoints;
            const wInc = computeWeightedIncrement(earnedPoints, { isQ3: true });
            gameState.weightedScore = (gameState.weightedScore || 0) + wInc;
            updateScoreDisplays();
            if (responseTime !== null) gameState.responseTimes.push(responseTime);
        }
        if (qArr.some(q => !q.userAnswer)) {
            let nextIdx = (idx + 1) % qArr.length;
            while (qArr[nextIdx].userAnswer) nextIdx = (nextIdx + 1) % qArr.length;
            gameState.q3CurrentQuestionIdx = nextIdx;
            showQ3CategoryQuestion();
        } else {
            finishQ3CategoryRound();
        }
        return;
    }

    if (gameState.answerTimer){ clearInterval(gameState.answerTimer); gameState.answerTimer = null; }
    $('answerInput').disabled = true;
    $('timerDisplay').textContent = "";

    if (gameState.currentQuarter === 1){
        basePoints = 10;
        if (isCorrect){
            earnedPoints = basePoints;
            gameState.rawScore += earnedPoints;
            const wInc = computeWeightedIncrement(earnedPoints, { isQ3: false, isQ2Bonus: false, percentDisplayed: computePercentDisplayed() });
            gameState.weightedScore = (gameState.weightedScore || 0) + wInc;
            gameState.questionsAttempted++;
            gameState.questionsCorrect++;
            updateScoreDisplays();
            if (gameState.mode === 'missed') {
              const questionText = gameState.currentQuestionText;
              missedQuestions = missedQuestions.filter(mq => mq.question !== questionText);
              saveMissedQuestions();
            }
            // *** FIX 3: Mark as mastered ***
            if (gameState.mode === 'practice') markQuestionMastered(1, gameState.currentQuestionText);
            if (responseTime !== null) gameState.responseTimes.push(responseTime);
            updateScoreDisplays();
            updateNodeProgressAfterCorrect();
            setFeedback(`Correct! +${earnedPoints} points (${responseTime?.toFixed(1)}s)`, true);
            scheduleNextQuestion(1500);
        } else {
            setFeedback(`Incorrect. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            gameState.questionsAttempted++;
            updateScoreDisplays();
            if (currentUser && gameState.mode !== 'missed') {
                const missedQ = { question: gameState.currentQuestionText, answer: gameState.currentAnswer, quarter: 1, timestamp: Date.now() };
                if (!missedQuestions.find(mq => mq.question === missedQ.question)) { missedQuestions.push(missedQ); saveMissedQuestions(); }
            }
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    } else if (gameState.currentQuarter === 2){
        basePoints = 10;
        if (isCorrect){
            earnedPoints = basePoints;
            gameState.rawScore += earnedPoints;
            const wInc = computeWeightedIncrement(earnedPoints, { isQ3: false, isQ2Bonus: false, percentDisplayed: computePercentDisplayed() });
            gameState.weightedScore = (gameState.weightedScore || 0) + wInc;
            gameState.questionsAttempted++;
            gameState.questionsCorrect++;
            updateScoreDisplays();
            const nodeAnswer2 = findNodeAnswer(gameState.currentAnswer);
            if (nodeAnswer2) { await syncKnowledgeGraphProgress(nodeAnswer2, true); }
            if (responseTime !== null) gameState.responseTimes.push(responseTime);
            updateScoreDisplays();
            setFeedback(`Correct tossup! +${earnedPoints} points. Now: bonus question.`, true);
            if (gameState.currentBonus){
                setTimeout(()=> {
                    $('questionText').textContent = gameState.currentBonus.question;
                    gameState.currentAnswer = preprocessAnswer(gameState.currentBonus.answer);
                    gameState.multiplier = 1;
                    $('answerInput').disabled = false;
                    $('answerInput').value = '';
                    $('answerInput').focus();
                    gameState.isAnsweringBonus = true;
                    gameState.questionStartTime = Date.now();
                    gameState.bonusTimeLeft = 20;
                    $('timerDisplay').textContent = `Bonus time: ${gameState.bonusTimeLeft}`;
                    gameState.bonusTimer = setInterval(() => {
                        gameState.bonusTimeLeft--;
                        $('timerDisplay').textContent = `Bonus time: ${gameState.bonusTimeLeft}`;
                        if (gameState.bonusTimeLeft <= 0) {
                            clearInterval(gameState.bonusTimer);
                            gameState.bonusTimer = null;
                            const typedText = $('answerInput').value.trim();
                            if (typedText && !$('answerInput').disabled) { submitAnswer(); return; }
                            $('answerInput').disabled = true;
                            $('timerDisplay').textContent = "Bonus expired";
                            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
                            startFeedbackCountdown(10);
                            $('questionText').textContent = gameState.currentBonus?.question || '';
                            gameState.currentBonus = null;
                            gameState.isAnsweringBonus = false;
                            scheduleNextQuestion(10000);
                        }
                    }, 1000);
                }, 1000);
            } else {
                scheduleNextQuestion(1500);
            }
        } else {
            setFeedback(`Incorrect tossup. The correct answer was: ${formatAnswer(gameState.currentAnswer)}. (No bonus.)`, false);
            gameState.questionsAttempted++;
            updateScoreDisplays();
            if (currentUser && gameState.mode !== 'missed') {
                const missedQ = { question: gameState.currentQuestionText, answer: gameState.currentAnswer, quarter: 2, type: 'tossup', timestamp: Date.now() };
                if (!missedQuestions.find(mq => mq.question === missedQ.question)) { missedQuestions.push(missedQ); saveMissedQuestions(); }
            }
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    } else if (gameState.currentQuarter === 4){
        const bracketPoints = gameState.q4BracketPoints || 10;
        basePoints = bracketPoints;
        if (isCorrect){
            earnedPoints = basePoints;
            gameState.rawScore += earnedPoints;
            const wInc = computeWeightedIncrement(earnedPoints, { isQ3: false, isQ2Bonus: false, percentDisplayed: computePercentDisplayed() });
            gameState.weightedScore = (gameState.weightedScore || 0) + wInc;
            gameState.questionsAttempted++;
            gameState.questionsCorrect++;
            updateScoreDisplays();
            if (responseTime !== null) gameState.responseTimes.push(responseTime);
            // *** FIX 3: Mark as mastered ***
            if (gameState.mode === 'practice') markQuestionMastered(4, gameState.currentQuestionText);
            updateScoreDisplays();
            setFeedback(`Correct! +${earnedPoints} points (${responseTime?.toFixed(1)}s)`, true);
            scheduleNextQuestion(1500);
        } else {
            gameState.questionsAttempted++;
            updateScoreDisplays();
            if (currentUser && gameState.mode !== 'missed') {
                const missedQ = { question: gameState.currentQuestionText, answer: gameState.currentAnswer, quarter: 4, timestamp: Date.now() };
                if (!missedQuestions.find(mq => mq.question === missedQ.question)) { missedQuestions.push(missedQ); saveMissedQuestions(); }
            }
            const nodeAnswer4 = findNodeAnswer(gameState.currentAnswer);
            if (nodeAnswer4) { await syncKnowledgeGraphProgress(nodeAnswer4, false); }
            setFeedback(`Incorrect. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            scheduleNextQuestion(10000);
        }
    }

    // Q2 bonus answer
    if (gameState.currentQuarter === 2 && gameState.isAnsweringBonus){
        const bonusIsCorrect = isCorrect;
        if (bonusIsCorrect){
            const bonusPoints = 10;
            gameState.rawScore += bonusPoints;
            const wInc = computeWeightedIncrement(bonusPoints, { isQ2Bonus: true });
            gameState.weightedScore = (gameState.weightedScore || 0) + wInc;
            updateScoreDisplays();
            const bonusResponseTime = (submitTime - gameState.questionStartTime) / 1000;
            gameState.responseTimes.push(bonusResponseTime);
            $('currentResponseTime').textContent = `Response time: ${bonusResponseTime.toFixed(1)}s`;
            updateScoreDisplays();
            // *** FIX 3: Mark Q2 tossup as mastered when both tossup+bonus answered correctly ***
            if (gameState.mode === 'practice') markQuestionMastered(2, gameState.currentQuestionText);
            setFeedback(`Correct bonus! +${bonusPoints} points (${bonusResponseTime.toFixed(1)}s)`, true);
            gameState.currentBonus = null;
            gameState.isAnsweringBonus = false;
            scheduleNextQuestion(1500);
        } else {
            setFeedback(`Incorrect bonus. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            if (currentUser && gameState.mode !== 'missed') {
                const missedQ = { question: gameState.currentBonus?.question || '', answer: gameState.currentAnswer, quarter: 2, type: 'bonus', timestamp: Date.now() };
                if (!missedQuestions.find(mq => mq.question === missedQ.question)) { missedQuestions.push(missedQ); saveMissedQuestions(); }
            }
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentBonus?.question || '';
            gameState.currentBonus = null;
            gameState.isAnsweringBonus = false;
            scheduleNextQuestion(10000);
        }
    }
}

function computeQuestionCounterText(){
    const q = gameState.currentQuarter;
    if (q === 1) return `Q ${Math.max(0, gameState.currentQuestionIndex+1)} / ${gameState.activeQ1?.length || 0}`;
    if (q === 2) return `Q ${Math.max(0, gameState.currentQuestionIndex+1)} / ${gameState.activeQ2?.length || 0}`;
    if (q === 3) return '';
    if (q === 4) return `Q ${Math.max(0, gameState.currentQuestionIndex+1)} / ${gameState.activeQ4?.length || 0}`;
    return '';
}

function startFeedbackCountdown(seconds) {
    $('timerDisplay').textContent = `Next question in: ${seconds}`;
    let timeLeft = seconds;
    gameState.feedbackTimeLeft = timeLeft;
    if (gameState.feedbackTimer) clearInterval(gameState.feedbackTimer);
    gameState.feedbackTimer = setInterval(() => {
        timeLeft--;
        gameState.feedbackTimeLeft = timeLeft;
        $('timerDisplay').textContent = `Next question in: ${timeLeft}`;
        if (timeLeft <= 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            $('timerDisplay').textContent = '--';
        }
    }, 1000);
}

function formatAnswer(ans) {
    if (Array.isArray(ans)) return ans.join(', ');
    if (typeof ans === 'string' && ans.includes(',')) return ans.split(',').map(s => s.trim()).join(', ');
    return ans;
}

async function finishGame() {
    clearAllTimers();
    const totalScore = gameState.rawScore;
    const avgBuzz = calculateAverageBuzzInTime();
    const playerName = $('playerNameInput').value.trim() || "Anonymous";
    const entry = {
      date: new Date().toISOString(),
      name: playerName,
      totalScore: gameState.rawScore,
      averageBuzzInTime: Math.round(avgBuzz*10)/10,
      weightedScore: Math.round(gameState.weightedScore)
    };
    await saveScoreToGlobalLeaderboard(entry);
    $('questionText').textContent = `Game finished! Score: ${totalScore} / Avg Buzz-in: ${avgBuzz ? avgBuzz.toFixed(1) + 's' : 'N/A'} . Saved to global leaderboard.`;
    setFeedback("Game complete ‚Äî check the leaderboard from the menu.", true);
    $('buzzerBtn').disabled = true;
    $('answerInput').disabled = true;
}

async function saveScoreToGlobalLeaderboard(entry) {
    try {
        const res = await fetch(WORKER_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(entry) });
        if (!res.ok) throw new Error(`Failed to save score: ${res.status} ${res.statusText}`);
        console.log("Score saved globally!");
    } catch (err) {
        console.error("Error saving score:", err);
        alert("Failed to save score to global leaderboard.");
    }
}

async function renderGlobalLeaderboard() {
    const container = document.getElementById('leaderboardList');
    container.innerHTML = `<div style="text-align:center;padding:30px;color:#666;"><div style="display:inline-block;width:20px;height:20px;border:3px solid #5a67d8;border-top:3px solid transparent;border-radius:50%;animation:spin 1s linear infinite;"></div><div style="margin-top:10px;">Loading leaderboard...</div></div>`;
    if (!document.getElementById('leaderboard-animations')) {
        const style = document.createElement('style');
        style.id = 'leaderboard-animations';
        style.textContent = `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`;
        document.head.appendChild(style);
    }
    try {
        const res = await fetch(WORKER_URL, { method: "GET" });
        if (!res.ok) throw new Error(`Failed to fetch leaderboard: ${res.status} ${res.statusText}`);
        const scores = await res.json();
        if (!scores.length) { container.innerHTML = '<div style="text-align:center;padding:40px;color:#666;font-size:1.1rem;">üèÜ No scores yet - be the first!</div>'; return; }
        const topScores = scores.sort((a, b) => { const wa = a.weightedScore || 0, wb = b.weightedScore || 0; if (wb !== wa) return wb - wa; return (b.totalScore || 0) - (a.totalScore || 0); });
        const formatDate = (dateStr) => { const date = new Date(dateStr); return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }); };
        container.innerHTML = '';
        topScores.forEach((e, idx) => {
            const entry = document.createElement('div');
            entry.className = 'leaderboard-entry';
            let nameStyle = '', rankStyle = '', medalEmoji = '', borderColor = '#5a67d8';
            const primaryScore = e.weightedScore !== undefined ? e.weightedScore : e.totalScore;
            const secondaryScore = e.totalScore !== undefined ? e.totalScore : 0;
            if (idx === 0) { nameStyle='color:#8646C7;font-weight:bold;font-size:1.3em;'; rankStyle='color:#8646C7;font-weight:800;text-shadow:1px 1px 2px rgba(134,70,199,0.2);'; borderColor='#8646C7'; medalEmoji='ü•á'; }
            else if (idx === 1) { nameStyle='color:#7146C7;font-weight:bold;font-size:1.25em;'; rankStyle='color:#7146C7;font-weight:800;'; borderColor='#7146C7'; medalEmoji='ü•à'; }
            else if (idx === 2) { nameStyle='color:#4E59BC;font-weight:bold;font-size:1.2em;'; rankStyle='color:#4E59BC;font-weight:800;'; borderColor='#4E59BC'; medalEmoji='ü•â'; }
            else if (idx===3||idx===4) { nameStyle='color:#457CB7;font-weight:600;font-size:1.1em;'; rankStyle='color:#457CB7;font-weight:800;'; borderColor='#457CB7'; }
            else { nameStyle='color:#2F547C;font-weight:600;font-size:1.05em;'; rankStyle='color:#2F547C;font-weight:800;'; borderColor='#2F547C'; }
            let backgroundGradient='rgba(255,255,255,0.9)';
            if (idx===0) backgroundGradient='linear-gradient(135deg,rgba(134,70,199,0.30) 0%,rgba(255,255,255,0.95) 100%)';
            else if (idx===1) backgroundGradient='linear-gradient(135deg,rgba(113,70,199,0.25) 0%,rgba(255,255,255,0.95) 100%)';
            else if (idx===2) backgroundGradient='linear-gradient(135deg,rgba(78,89,188,0.20) 0%,rgba(255,255,255,0.95) 100%)';
            else if (idx===3||idx===4) backgroundGradient='linear-gradient(135deg,rgba(69,124,183,0.15) 0%,rgba(255,255,255,0.95) 100%)';
            else backgroundGradient='linear-gradient(135deg,rgba(47,84,124,0.10) 0%,rgba(255,255,255,0.95) 100%)';
            entry.style.border = `2px solid ${borderColor}`;
            entry.style.background = backgroundGradient;
            entry.style.borderRadius = '10px';
            entry.style.padding = '8px';
            entry.style.marginBottom = '6px';
            entry.style.display = 'flex';
            entry.style.alignItems = 'center';
            entry.style.justifyContent = 'space-between';
            entry.innerHTML = `<span style="${rankStyle} font-size:1.1rem; min-width:35px; text-align:center; margin-right:12px;">${idx+1} ${medalEmoji}</span><div style="flex:1; margin:0 12px;"><div style="${nameStyle} margin-bottom:3px; line-height:1.1;">${e.name || "Anonymous"}</div><div style="font-size:0.8rem; color:#666; display:flex; gap:10px; flex-wrap:wrap; align-items:center;"><span style="background:rgba(90,103,216,0.1); padding:2px 6px; border-radius:8px; font-size:0.75rem; font-weight:500; color:#5a67d8;">‚ö° ${e.averageBuzzInTime ? e.averageBuzzInTime.toFixed(1)+'s' : 'N/A'}</span><span style="background:rgba(108,117,125,0.1); padding:2px 6px; border-radius:8px; font-size:0.75rem; font-weight:500; color:#6c757d;">üìÖ ${formatDate(e.date)}</span></div></div><div style="${rankStyle} font-size:1.3rem; font-weight:800; text-align:right; min-width:60px; background:rgba(255,255,255,0.7); padding:6px 10px; border-radius:8px; box-shadow:0 1px 6px rgba(0,0,0,0.08);"><div style="font-size:1.25rem; font-weight:800;">${primaryScore}</div><div style="font-size:0.85rem; margin-top:4px; color:#555;">pts: ${secondaryScore}</div></div>`;
            container.appendChild(entry);
        });
        const footer = document.createElement('div');
        footer.style.textAlign = 'center';
        footer.style.marginTop = '16px';
        footer.style.paddingTop = '12px';
        footer.style.borderTop = '2px solid rgba(90,103,216,0.1)';
        footer.style.color = '#666';
        footer.style.fontSize = '0.9rem';
        footer.style.fontWeight = '500';
        footer.textContent = `üèÜ Showing ${topScores.length} scores ‚Ä¢ Updated live`;
        container.appendChild(footer);
    } catch (err) {
        console.error(err);
        container.innerHTML = `<div style="text-align:center; padding:40px; color:#e53e3e; font-size:1.1rem; background:linear-gradient(135deg,rgba(229,62,62,0.1) 0%,rgba(255,255,255,0.95) 100%); border-radius:12px; border:2px solid rgba(229,62,62,0.2);">‚ö†Ô∏è Failed to load leaderboard<br><span style="font-size:0.9rem; color:#666; margin-top:8px; display:block;">Please try again later</span></div>`;
    }
}

function renderQuestionsDisplay(){
    const container = $('questionsDisplay');
    container.innerHTML = '';
    let q1count, q2count, q3count, q4count;
    if (gameState.mode === 'practice') {
        q1count = gameState.activeQ1?.length ?? 0;
        q2count = gameState.activeQ2?.length ?? 0;
        q3count = gameState.activeQ3?.length ?? 0;
        q4count = gameState.activeQ4?.length ?? 0;
    } else {
        q1count = QUESTIONS.q1.length;
        q2count = QUESTIONS.q2.length;
        q3count = QUESTIONS.q3.length;
        q4count = QUESTIONS.q4.length;
    }
    const summary = document.createElement('div');
    summary.innerHTML = `<h4>Loaded Questions Summary:</h4><p>Quarter 1: ${q1count} questions</p><p>Quarter 2: ${q2count*2} questions</p><p>Quarter 3: ${q3count} categories, ${q3count*8} questions</p><p>Quarter 4: ${q4count} questions</p><p>All Quarters: ${q1count+q2count*2+q3count*8+q4count} questions</p>`;
    container.appendChild(summary);
}

function promptPracticeSet() {
  return new Promise((resolve) => {
    const availableFiles = window.AVAILABLE_FILES;
    openSetPicker(availableFiles, async (selectedFiles) => {
        if (!selectedFiles || !selectedFiles.length) { resolve(null); return; }
        resolve(selectedFiles);
    }, 'Select Practice Sets');
  });
}

document.addEventListener('keydown', function(e){
    if (e.key === 'Enter'){
        if (!gameState.isPaused && !$('answerInput').disabled && document.activeElement === $('answerInput')){
            submitAnswer();
        }
    }
});

function openKnowledgeGraph() { window.open('knowledge-graph.html', '_blank'); }

function checkReviewMode() {
    const params = new URLSearchParams(window.location.search);
    if (params.get('mode') === 'review') {
        const nodeAnswer = sessionStorage.getItem('reviewNodeAnswer');
        const nodeQuestions = sessionStorage.getItem('reviewNodeQuestions');
        const nodeId = sessionStorage.getItem('reviewNodeId');
        if (nodeAnswer && nodeQuestions) {
            const questions = JSON.parse(nodeQuestions);
            startReviewGameForNode(nodeAnswer, questions, nodeId);
        }
    }
}

function startReviewGameForNode(answer, questions, nodeId) {
    const reviewQuestions = questions.map(q => ({ question: q, answer: answer }));
    gameState.mode = 'review';
    gameState.reviewNodeId = nodeId;
    gameState.currentQuarter = 1;
    gameState.activeQ1 = reviewQuestions;
    gameState.activeQ2 = [];
    gameState.activeQ3 = [];
    gameState.activeQ4 = [];
    $('mainMenu').style.display = 'none';
    $('gameArea').style.display = 'block';
    $('modeDisplay').textContent = 'Review: ' + answer;
    $('showAnswerBtn').style.display = 'inline-block';
    updatePauseButtonVisibility();
    resetGame();
    nextQuestion();
}

function updateNodeProgressAfterCorrect() {
  if (gameState.mode === 'review' && gameState.reviewNodeId) {
    const nodeId = gameState.reviewNodeId;
    const user = sessionStorage.getItem('knowledgeGraphUser') || 'guest';
    const key = 'historyBowlProgress_' + user;
    const progress = JSON.parse(localStorage.getItem(key) || '{}');
    if (!progress[nodeId]) progress[nodeId] = { stars: 0, times_correct: 0, times_wrong: 0 };
    progress[nodeId].times_correct = (progress[nodeId].times_correct || 0) + 1;
    if (progress[nodeId].stars < 2) progress[nodeId].stars = 2;
    progress[nodeId].lastReviewed = Date.now();
    localStorage.setItem(key, JSON.stringify(progress));
  }
}

function showLoginModal() { document.getElementById('loginModal').style.display = 'flex'; }
function closeLoginModal() { document.getElementById('loginModal').style.display = 'none'; document.getElementById('loginError').textContent = ''; }

async function login() {
  const username = document.getElementById('loginUsername').value.trim();
  const password = document.getElementById('loginPassword').value;
  if (!username || !password) { document.getElementById('loginError').textContent = 'Please enter username and password'; return; }
  try {
    const res = await fetch(`${WORKER_URL}/auth/login`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username, password }) });
    const data = await res.json();
    if (data.success) {
      currentUser = username;
      document.getElementById('username-display').textContent = username;
      document.getElementById('playerNameInput').value = username;
      localStorage.setItem('currentUser', username);
      sessionStorage.setItem('knowledgeGraphUser', username);
      await loadUserProgress();
      await loadMissedQuestions();
      await loadMasteredQuestions();
      updateAuthUI();
      closeLoginModal();
    } else { document.getElementById('loginError').textContent = data.message || 'Invalid credentials'; }
  } catch (err) { console.error('Login error:', err); document.getElementById('loginError').textContent = 'Login failed. Please try again.'; }
}

async function register() {
  const username = document.getElementById('loginUsername').value.trim();
  const password = document.getElementById('loginPassword').value;
  if (!username || !password) { document.getElementById('loginError').textContent = 'Please enter username and password'; return; }
  try {
    const res = await fetch(`${WORKER_URL}/auth/register`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username, password }) });
    const data = await res.json();
    if (data.success) { document.getElementById('loginError').textContent = 'Registration successful! Now login.'; document.getElementById('loginError').style.color = 'green'; }
    else { document.getElementById('loginError').textContent = data.message || 'Registration failed'; document.getElementById('loginError').style.color = 'red'; }
  } catch (err) { console.error('Register error:', err); document.getElementById('loginError').textContent = 'Registration failed. Please try again.'; }
}

function updateAuthUI() {
  const loginBtn = document.getElementById('loginBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  if (!loginBtn || !logoutBtn) return;
  if (currentUser) {
    loginBtn.style.display = 'none';
    logoutBtn.style.display = 'inline-block';
  } else {
    loginBtn.style.display = 'inline-block';
    logoutBtn.style.display = 'none';
  }
}
    
function logout() {
  currentUser = null;
  document.getElementById('username-display').textContent = 'Guest';
  document.getElementById('playerNameInput').value = '';
  localStorage.removeItem('currentUser');
  sessionStorage.removeItem('knowledgeGraphUser');
  missedQuestions = [];
  masteredQuestions = new Set();
  updateAuthUI();
}

async function loadUserProgress() {
  if (!currentUser) return;
  try {
    const res = await fetch(`${WORKER_URL}/progress/${currentUser}`);
    if (res.ok) {
      const serverProgress = await res.json();
      localStorage.setItem('knowledgeGraphProgress_' + currentUser, JSON.stringify(serverProgress));
    }
  } catch (err) { console.error('Failed to load progress:', err); }
}

async function saveUserProgress() {
  if (!currentUser) return;
  try {
    const progressData = JSON.parse(localStorage.getItem('knowledgeGraphProgress_' + currentUser) || '{}');
    await fetch(`${WORKER_URL}/progress/${currentUser}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(progressData) });
  } catch (err) { console.error('Failed to save progress:', err); }
}

async function loadMissedQuestions() {
  if (!currentUser) return;
  const saved = localStorage.getItem('missedQuestions_' + currentUser);
  if (saved) missedQuestions = JSON.parse(saved);
}

function saveMissedQuestions() {
  if (!currentUser) return;
  localStorage.setItem('missedQuestions_' + currentUser, JSON.stringify(missedQuestions));
}
  
async function init(){
    resetGame();
    updateScoreDisplays();
    updateQuestionsStatus('Loading questions from server...', true);
    loadQuestionsFromServer();
    try {
        const nodesRes = await fetch('graph_data/output_nodes.json');
        if (nodesRes.ok) { knowledgeGraphNodes = await nodesRes.json(); console.log('‚úì Loaded knowledge graph nodes for matching'); }
    } catch (err) { console.warn('Knowledge graph nodes not available:', err); }
    checkReviewMode();
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
    script.onload = () => console.log('jsPDF loaded');
    script.onerror = () => console.error('Failed to load jsPDF');
    document.head.appendChild(script);
    const savedUser = localStorage.getItem('currentUser') || sessionStorage.getItem('knowledgeGraphUser');
    if (savedUser) {
        currentUser = savedUser;
        document.getElementById('username-display').textContent = savedUser;
        document.getElementById('playerNameInput').value = savedUser;
        loadUserProgress();
        loadMissedQuestions();
        loadMasteredQuestions();
    } else {
        loadMasteredQuestions(); // load guest mastered from localStorage
    }
    setTimeout(updateAuthUI, 500);
}
init();

/* ---- PDF Functions (unchanged from original) ---- */
function renderPDFQuestionsList() {
    const container = $('pdfQuestionsList');
    if (!container) return;
    if (!gameState.pdfQuestions) gameState.pdfQuestions = { q1: [], q2: [], q3: [], q4: [] };
    const total = gameState.pdfQuestions.q1.length + gameState.pdfQuestions.q2.length + gameState.pdfQuestions.q3.length + gameState.pdfQuestions.q4.length;
    if (total === 0) { container.innerHTML = '<p style="color:#666;">No questions selected yet.</p>'; return; }
    let html = `<p><strong>Total: ${total} questions</strong></p><p>Q1: ${gameState.pdfQuestions.q1.length} | Q2: ${gameState.pdfQuestions.q2.length} | Q3: ${gameState.pdfQuestions.q3.length} categories | Q4: ${gameState.pdfQuestions.q4.length}</p>`;
    container.innerHTML = html;
}

function addCurrentQuestionToPDF() {
    if (!gameState.pdfQuestions) gameState.pdfQuestions = { q1: [], q2: [], q3: [], q4: [] };
    const checkbox = $('addToPDFCheckbox');
    if (!checkbox || !checkbox.checked) return;
    const q = gameState.currentQuarter;
    if (q === 1) {
        const question = gameState.activeQ1[gameState.currentQuestionIndex];
        if (question && !gameState.pdfQuestions.q1.some(q => q.question === question.question)) gameState.pdfQuestions.q1.push(question);
    } else if (q === 2) {
        const question = gameState.activeQ2[gameState.currentQuestionIndex];
        if (question && !gameState.pdfQuestions.q2.some(q => q.tossup.question === question.tossup.question)) gameState.pdfQuestions.q2.push(question);
    } else if (q === 3 && gameState.q3SelectedCategoryData) {
        if (!gameState.pdfQuestions.q3.some(cat => cat.category === gameState.q3SelectedCategoryData.category)) gameState.pdfQuestions.q3.push(gameState.q3SelectedCategoryData);
    } else if (q === 4) {
        const question = gameState.activeQ4[gameState.currentQuestionIndex];
        if (question && !gameState.pdfQuestions.q4.some(q => q.parts[0] === question.parts[0])) gameState.pdfQuestions.q4.push(question);
    }
    checkbox.checked = false;
}

function clearPDFQuestions() {
    if (confirm('Clear all selected PDF questions?')) {
        gameState.pdfQuestions = { q1: [], q2: [], q3: [], q4: [] };
        renderPDFQuestionsList();
    }
}

async function generateSamplePDFs() {
  if (!gameState.pdfQuestions) gameState.pdfQuestions = { q1: [], q2: [], q3: [], q4: [] };
  const prefilled = gameState.pdfQuestions.q1.length + gameState.pdfQuestions.q2.length + gameState.pdfQuestions.q3.length + gameState.pdfQuestions.q4.length;
  if (prefilled > 0) { alert('Please clear the PDF before generating sample PDFs.'); return; }
  const availableFiles = window.AVAILABLE_FILES;
  if (!availableFiles || !availableFiles.length) { alert('No sets available.'); return; }
  const selectedFiles = await new Promise(resolve => openSetPicker(availableFiles, files => resolve(files), 'Select PDF Sources'));
  if (!selectedFiles || !selectedFiles.length) return;
  await loadAllQuestionSets(selectedFiles);
  if (!QUESTIONS_SETS.length) { alert("Failed to load selected question sets."); return; }
  const q1Pool = QUESTIONS_SETS.flatMap(s => s.q1 || []).filter(q => !String(q.question || '').toUpperCase().startsWith('(TIEBREAKER'));
  const q2Pool = QUESTIONS_SETS.flatMap(s => s.q2 || []).filter(q => !String(q.tossup?.question || '').toUpperCase().startsWith('(TIEBREAKER'));
  const q3Pool = QUESTIONS_SETS.flatMap(s => s.q3 || []);
  const q4Pool = QUESTIONS_SETS.flatMap(s => s.q4 || []).filter(q => { const p0 = String(q.parts?.[0] || '').toUpperCase(); return !p0.startsWith('(TIEBREAKER'); });
  if (!q1Pool.length && !q2Pool.length && !q3Pool.length && !q4Pool.length) { alert('No questions found.'); return; }
  const shuffleArr = (arr) => { const a = [...arr]; for (let i=a.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };
  const pickN = (arr, n) => shuffleArr(arr).slice(0, Math.min(n, arr.length));
  gameState.pdfQuestions.q1 = pickN(q1Pool, 10);
  gameState.pdfQuestions.q2 = pickN(q2Pool, 8);
  gameState.pdfQuestions.q4 = pickN(q4Pool, 8);
  if (q3Pool.length) {
    const ordered = weightedPickCategories(q3Pool, practiceCategoryWeights) || [];
    const pick3 = [];
    for (const c of ordered) { if (!pick3.find(x => (x.category || '') === (c.category || ''))) pick3.push(c); if (pick3.length === 3) break; }
    const remainder = q3Pool.filter(c => !pick3.find(x => (x.category || '') === (c.category || '')));
    let mandatory = remainder.length ? remainder[Math.floor(Math.random() * remainder.length)] : q3Pool[Math.floor(Math.random() * q3Pool.length)];
    mandatory = { ...mandatory, _mandatory: true };
    gameState.pdfQuestions.q3 = [...pick3, mandatory];
  } else { gameState.pdfQuestions.q3 = []; }
  alert('Sample PDFs generated! Click "Export PDFs" to open them.');
}

function cleanTiebreakerText(text) { return String(text || '').replace(/^\(TIEBREAKER (EXAMPLE|BONUS) QUESTION\)\s*/i, '').replace(/^\(TIEBREAKER\)\s*/i, ''); }
function replaceAnswerInBonus(bonusQuestion, tossupAnswer) {
  const answerVariants = Array.isArray(tossupAnswer) ? tossupAnswer : [tossupAnswer];
  let result = String(bonusQuestion || '');
  for (const ans of answerVariants) { const safe = String(ans || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); const regex = new RegExp(safe, 'gi'); result = result.replace(regex, '[Previous Answer]'); }
  return result;
}

async function exportPDFs() {
  if (!gameState.pdfQuestions) gameState.pdfQuestions = { q1: [], q2: [], q3: [], q4: [] };
  const total = gameState.pdfQuestions.q1.length + gameState.pdfQuestions.q2.length + gameState.pdfQuestions.q3.length + gameState.pdfQuestions.q4.length;
  if (total === 0) { alert('No questions selected.'); return; }
  if (typeof window.jspdf === 'undefined') { alert('PDF library is still loading. Please try again in a moment.'); return; }
  const sanitize = (s) => String(s ?? '').replace(/\r\n?/g, '\n').replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim();
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF();
  const answerKeyPDF = new jsPDF();
  const margin = 20, maxWidth = 170, maxWidthAnswer = 165, pageHeight = pdf.internal.pageSize.getHeight(), underscoreLen = 75;
  const lhFromFont = (doc) => Math.round(doc.getFontSize() * 0.5);
  let yPos = 20, answerYPos = 20;
  const needsNewPage = (requiredSpace, isAnswer) => (isAnswer ? answerYPos : yPos) + requiredSpace > (pageHeight - 10);
  const addNewPage = (doc, isAnswer) => { doc.addPage(); if (isAnswer) answerYPos = 20; else yPos = 20; };
  const addWrappedText = (doc, text, x, startY, maxW, isAnswer = false) => {
    const clean = sanitize(text);
    const lh = lhFromFont(doc);
    const lines = doc.splitTextToSize(clean, maxW);
    let currentY = isAnswer ? answerYPos : yPos;
    const requiredSpace = lines.length * lh;
    if (currentY + requiredSpace > pageHeight - 10) { addNewPage(doc, isAnswer); currentY = isAnswer ? answerYPos : yPos; }
    lines.forEach(line => { doc.text(line, x, currentY); currentY += lh; });
    if (isAnswer) answerYPos = currentY; else yPos = currentY;
    return { requiredSpace };
  };
  pdf.setFontSize(16); pdf.setFont(undefined, 'bold'); pdf.text('History Bowl Practice Test', margin, yPos);
  answerKeyPDF.setFontSize(16); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text('History Bowl Practice Test - Answer Key', margin, answerYPos);
  yPos += 10; answerYPos += 10;
  const today = new Date().toLocaleDateString();
  pdf.setFontSize(10); pdf.setFont(undefined, 'normal'); pdf.text(`Generated: ${today}`, margin, yPos);
  answerKeyPDF.setFontSize(10); answerKeyPDF.setFont(undefined, 'normal'); answerKeyPDF.text(`Generated: ${today}`, margin, answerYPos);
  yPos += 16; answerYPos += 16;
  // Q1
  if (gameState.pdfQuestions.q1.length > 0) {
    pdf.setFontSize(16); pdf.setFont(undefined, 'bold'); pdf.text('Quarter 1', margin, yPos); yPos += 8;
    answerKeyPDF.setFontSize(16); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text('Quarter 1', margin, answerYPos); answerYPos += 8;
    pdf.setFontSize(13); pdf.setFont(undefined, 'normal'); answerKeyPDF.setFontSize(13); answerKeyPDF.setFont(undefined, 'normal');
    gameState.pdfQuestions.q1.forEach((q, i) => {
      const qText = `${i + 1}. ${sanitize(cleanTiebreakerText(q.question))}`;
      const lh = lhFromFont(pdf); const req = pdf.splitTextToSize(qText, maxWidth).length * lh + 14;
      if (needsNewPage(req, false)) addNewPage(pdf, false);
      if (needsNewPage(req, true)) addNewPage(answerKeyPDF, true);
      addWrappedText(pdf, qText, margin, yPos, maxWidth, false); yPos += 2; pdf.text('_'.repeat(underscoreLen), margin, yPos); yPos += 12;
      addWrappedText(answerKeyPDF, qText, margin, answerYPos, maxWidthAnswer, true); answerYPos += 2;
      addWrappedText(answerKeyPDF, sanitize(formatAnswer(q.answer)), margin, answerYPos, maxWidthAnswer, true); answerYPos += 12;
    });
  }
  // Q2
  if (gameState.pdfQuestions.q2.length > 0) {
    addNewPage(pdf, false); addNewPage(answerKeyPDF, true);
    pdf.setFontSize(16); pdf.setFont(undefined, 'bold'); pdf.text('Quarter 2', margin, yPos); yPos += 8;
    answerKeyPDF.setFontSize(16); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text('Quarter 2', margin, answerYPos); answerYPos += 8;
    pdf.setFontSize(13); pdf.setFont(undefined, 'normal'); answerKeyPDF.setFontSize(13); answerKeyPDF.setFont(undefined, 'normal');
    gameState.pdfQuestions.q2.forEach((q, i) => {
      const cleanTossup = sanitize(cleanTiebreakerText(q.tossup.question));
      const cleanBonus = sanitize(cleanTiebreakerText(q.bonus.question));
      const bonusWithReplacement = replaceAnswerInBonus(cleanBonus, q.tossup.answer);
      const lh = lhFromFont(pdf); const tossReq = pdf.splitTextToSize(`${i+1}. TOSSUP: ${cleanTossup}`, maxWidth).length * lh + 14;
      if (needsNewPage(tossReq, false)) addNewPage(pdf, false);
      if (needsNewPage(tossReq, true)) addNewPage(answerKeyPDF, true);
      addWrappedText(pdf, `${i + 1}. TOSSUP: ${cleanTossup}`, margin, yPos, maxWidth, false); yPos += 2; pdf.text('_'.repeat(underscoreLen), margin, yPos); yPos += 10;
      addWrappedText(answerKeyPDF, `${i + 1}. TOSSUP: ${cleanTossup}`, margin, answerYPos, maxWidthAnswer, true); answerYPos += 2;
      addWrappedText(answerKeyPDF, sanitize(formatAnswer(q.tossup.answer)), margin, answerYPos, maxWidthAnswer, true); answerYPos += 10;
      const bonusReq = pdf.splitTextToSize(`BONUS: ${bonusWithReplacement}`, maxWidth).length * lh + 14;
      if (needsNewPage(bonusReq, false)) addNewPage(pdf, false);
      if (needsNewPage(bonusReq, true)) addNewPage(answerKeyPDF, true);
      addWrappedText(pdf, `BONUS: ${bonusWithReplacement}`, margin, yPos, maxWidth, false); yPos += 2; pdf.text('_'.repeat(underscoreLen), margin, yPos); yPos += 12;
      addWrappedText(answerKeyPDF, `BONUS: ${cleanBonus}`, margin, answerYPos, maxWidthAnswer, true); answerYPos += 2;
      addWrappedText(answerKeyPDF, sanitize(formatAnswer(q.bonus.answer)), margin, answerYPos, maxWidthAnswer, true); answerYPos += 12;
    });
  }
  // Q3
  if (gameState.pdfQuestions.q3.length > 0) {
    addNewPage(pdf, false); addNewPage(answerKeyPDF, true);
    pdf.setFontSize(16); pdf.setFont(undefined, 'bold'); pdf.text('Quarter 3', margin, yPos); yPos += 8;
    answerKeyPDF.setFontSize(16); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text('Quarter 3', margin, answerYPos); answerYPos += 8;
    pdf.setFontSize(13); pdf.setFont(undefined, 'normal'); answerKeyPDF.setFontSize(13); answerKeyPDF.setFont(undefined, 'normal');
    pdf.text('Categories:', margin, yPos); yPos += 7;
    answerKeyPDF.text('Categories:', margin, answerYPos); answerYPos += 7;
    (gameState.pdfQuestions.q3 || []).forEach((cat, i) => {
      const label = `${i + 1}. ${sanitize(cat.category || '')}${cat._mandatory ? ' (MANDATORY)' : ''}`;
      pdf.text(label, margin + 5, yPos); yPos += 6;
      answerKeyPDF.text(label, margin + 5, answerYPos); answerYPos += 6;
    });
    pdf.text('(Select any of the first 3; #4 is mandatory.)', margin, yPos, {maxWidth}); yPos += 12;
    answerKeyPDF.text('(Select any of the first 3; #4 is mandatory.)', margin, answerYPos, {maxWidth: maxWidthAnswer}); answerYPos += 12;
    (gameState.pdfQuestions.q3 || []).forEach(cat => {
      addNewPage(pdf, false); addNewPage(answerKeyPDF, true);
      pdf.setFontSize(12); pdf.setFont(undefined, 'bold'); pdf.text(String(cat.category || '').toUpperCase(), margin, yPos); yPos += 8;
      answerKeyPDF.setFontSize(12); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text(String(cat.category || '').toUpperCase(), margin, answerYPos); answerYPos += 8;
      pdf.setFontSize(13); pdf.setFont(undefined, 'normal'); answerKeyPDF.setFontSize(13); answerKeyPDF.setFont(undefined, 'normal');
      addWrappedText(pdf, sanitize(cat.prompt || 'Name the...'), margin, yPos, maxWidth, false); yPos += 10;
      addWrappedText(answerKeyPDF, sanitize(cat.prompt || 'Name the...'), margin, answerYPos, maxWidthAnswer, true); answerYPos += 10;
      (cat.questions || []).forEach((q, i) => {
        const text = `${i + 1}. ${sanitize(cleanTiebreakerText(q.question))}`;
        const lh = lhFromFont(pdf); const req = pdf.splitTextToSize(text, maxWidth).length * lh + 12;
        if (needsNewPage(req, false)) addNewPage(pdf, false);
        if (needsNewPage(req, true)) addNewPage(answerKeyPDF, true);
        addWrappedText(pdf, text, margin, yPos, maxWidth, false); yPos += 2; pdf.text('_'.repeat(underscoreLen), margin, yPos); yPos += 12;
        addWrappedText(answerKeyPDF, text, margin, answerYPos, maxWidthAnswer, true); answerYPos += 2;
        addWrappedText(answerKeyPDF, sanitize(formatAnswer(q.answer)), margin, answerYPos, maxWidthAnswer, true); answerYPos += 12;
      });
    });
  }
  // Q4
  if (gameState.pdfQuestions.q4.length > 0) {
    addNewPage(pdf, false);
    pdf.setFontSize(16); pdf.setFont(undefined, 'bold'); pdf.text('Quarter 4', margin, yPos); yPos += 8;
    pdf.setFontSize(9); pdf.setFont(undefined, 'normal');
    pdf.text('Scoring: Answer in earliest section = 4.5 pts, next = 3 pts, last = 1.5 pts.', margin, yPos, {maxWidth}); yPos += 10;
    ['Section 1: Earliest (4.5 pts)', 'Section 2: Middle (3 pts)', 'Section 3: Last (1.5 pts)'].forEach((sectionTitle, sectionIdx) => {
      if (sectionIdx > 0) addNewPage(pdf, false);
      pdf.setFontSize(12); pdf.setFont(undefined, 'bold'); pdf.text(sectionTitle, margin, yPos); yPos += 8;
      pdf.setFontSize(13); pdf.setFont(undefined, 'normal');
      gameState.pdfQuestions.q4.forEach((q, i) => {
        let display;
        if (sectionIdx === 0) display = sanitize(cleanTiebreakerText(q.parts[0]));
        else if (sectionIdx === 1) display = [sanitize(cleanTiebreakerText(q.parts[0]||'')), sanitize(cleanTiebreakerText(q.parts[1]||''))].filter(Boolean).join(' ‚Äî ');
        else display = [q.parts[0],q.parts[1],q.parts[2]].map(p=>sanitize(cleanTiebreakerText(p||''))).filter(Boolean).join(' ‚Äî ');
        const lhQ = lhFromFont(pdf); const reqQ = pdf.splitTextToSize(`${i+1}. ${display}`, maxWidth).length * lhQ + 12;
        if (needsNewPage(reqQ, false)) addNewPage(pdf, false);
        addWrappedText(pdf, `${i + 1}. ${display}`, margin, yPos, maxWidth, false); yPos += 2; pdf.text('_'.repeat(underscoreLen), margin, yPos); yPos += 12;
      });
    });
    addNewPage(answerKeyPDF, true);
    answerKeyPDF.setFontSize(16); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text('Quarter 4', margin, answerYPos); answerYPos += 8;
    answerKeyPDF.setFontSize(12); answerKeyPDF.setFont(undefined, 'bold'); answerKeyPDF.text('Section 3: Last (1.5 pts)', margin, answerYPos); answerYPos += 8;
    answerKeyPDF.setFontSize(13); answerKeyPDF.setFont(undefined, 'normal');
    gameState.pdfQuestions.q4.forEach((q, i) => {
      const combined = [q.parts[0],q.parts[1],q.parts[2]].map(p=>sanitize(cleanTiebreakerText(p||''))).filter(Boolean).join(' ‚Äî ');
      const lhA = lhFromFont(answerKeyPDF); const reqA = answerKeyPDF.splitTextToSize(`${i+1}. ${combined}`, maxWidthAnswer).length * lhA + 12;
      if (needsNewPage(reqA, true)) addNewPage(answerKeyPDF, true);
      addWrappedText(answerKeyPDF, `${i + 1}. ${combined}`, margin, answerYPos, maxWidthAnswer, true); answerYPos += 2;
      addWrappedText(answerKeyPDF, sanitize(formatAnswer(q.answer)), margin, answerYPos, maxWidthAnswer, true); answerYPos += 12;
    });
  }
  const practiceBlob = pdf.output('blob');
  const answerKeyBlob = answerKeyPDF.output('blob');
  const practiceUrl = URL.createObjectURL(practiceBlob);
  const answerKeyUrl = URL.createObjectURL(answerKeyBlob);
  setTimeout(() => { window.open(practiceUrl, '_blank'); setTimeout(() => { window.open(answerKeyUrl, '_blank'); alert('Both PDFs opened. Use the browser viewer to download.'); }, 300); }, 200);
}

function updateNodeProgressAfterCorrect() {
  if (gameState.mode === 'review' && gameState.reviewNodeId) {
    const nodeId = gameState.reviewNodeId;
    const user = sessionStorage.getItem('knowledgeGraphUser') || 'guest';
    const key = 'historyBowlProgress_' + user;
    const progress = JSON.parse(localStorage.getItem(key) || '{}');
    if (!progress[nodeId]) progress[nodeId] = { stars: 0, times_correct: 0, times_wrong: 0 };
    progress[nodeId].times_correct = (progress[nodeId].times_correct || 0) + 1;
    if (progress[nodeId].stars < 2) progress[nodeId].stars = 2;
    progress[nodeId].lastReviewed = Date.now();
    localStorage.setItem(key, JSON.stringify(progress));
  }
}

async function syncKnowledgeGraphProgress(nodeAnswer, correct) {
  const username = currentUser || 'guest';
  const normalizedAnswer = normalizeAnswer(nodeAnswer);
  try {
    const res = await fetch(`${WORKER_URL}/progress/${username}`);
    const progress = res.ok ? await res.json() : {};
    if (!progress[normalizedAnswer]) progress[normalizedAnswer] = { stars: 0, times_correct: 0, times_wrong: 0 };
    if (correct) { progress[normalizedAnswer].times_correct = (progress[normalizedAnswer].times_correct || 0) + 1; if (progress[normalizedAnswer].stars < 2) progress[normalizedAnswer].stars = 2; }
    else {
      progress[normalizedAnswer].times_wrong = (progress[normalizedAnswer].times_wrong || 0) + 1;
      if (currentUser && gameState.mode !== 'missed') {
        const missedQ = { question: gameState.currentQuestionText, answer: gameState.currentAnswer, quarter: gameState.currentQuarter, timestamp: Date.now() };
        if (!missedQuestions.find(mq => mq.question === missedQ.question)) { missedQuestions.push(missedQ); saveMissedQuestions(); }
      }
    }
    progress[normalizedAnswer].lastReviewed = Date.now();
    await fetch(`${WORKER_URL}/progress/${username}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(progress) });
  } catch (err) { console.error('Failed to sync knowledge graph:', err); }
}

function checkKnowledgeGraphUser() {
  const kgUser = sessionStorage.getItem('knowledgeGraphUser');
  if (kgUser) { currentUser = kgUser; document.getElementById('playerNameInput').value = kgUser; localStorage.setItem('currentUser', kgUser); }
}

window.addEventListener('load', () => { checkKnowledgeGraphUser(); });

function normalizeAnswer(answer) {
  if (!answer) return '';
  return String(answer).toLowerCase().replace(/'/g, "'").replace(/'/g, "'").trim();
}

window.AVAILABLE_FILES = [
        {
            year: "Categories",
            sets: [
                { name: "US History", file: "historybowlquestionsets/categories/a/aus_history_questions.json" },
                { name: "European History", file: "historybowlquestionsets/categories/a/aeuropean_history_questions.json" },
                { name: "World History", file: "historybowlquestionsets/categories/a/aworld_history_questions.json" },
                { name: "Other History", file: "historybowlquestionsets/categories/a/aother_history_questions.json" },
                { name: "Ancient History", file: "historybowlquestionsets/categories/a/aancient_history_questions.json" },
                { name: "Geographical History", file: "historybowlquestionsets/categories/a/ageographical_history_questions.json" },
                { name: "Fine Arts History", file: "historybowlquestionsets/categories/a/afine_arts_history_questions.json" },
                { name: "Math and Science History", file: "historybowlquestionsets/categories/a/amath_science_history_questions.json" },
                { name: "Pop Culture/Sports History", file: "historybowlquestionsets/categories/a/apop_culture_sports_history_questions.json" },
                { name: "Social Science/Philosophy", file: "historybowlquestionsets/categories/a/asocial_science_philosophy_questions.json" },
                { name: "Literature History", file: "historybowlquestionsets/categories/a/aliterature_history_questions.json" },
                { name: "Recent History (2000-Present)", file: "historybowlquestionsets/categories/a/arecent_history_questions.json" },
                { name: "Mythology", file: "historybowlquestionsets/categories/a/amythology_questions.json" },
              
                { name: "US History", file: "historybowlquestionsets/categories/b/bus_history_questions.json" },
                { name: "European History", file: "historybowlquestionsets/categories/b/beuropean_history_questions.json" },
                { name: "World History", file: "historybowlquestionsets/categories/b/bworld_history_questions.json" },
                { name: "Other History", file: "historybowlquestionsets/categories/b/bother_history_questions.json" },
                { name: "Ancient History", file: "historybowlquestionsets/categories/b/bancient_history_questions.json" },
                { name: "Geographical History", file: "historybowlquestionsets/categories/b/bgeographical_history_questions.json" },
                { name: "Fine Arts History", file: "historybowlquestionsets/categories/b/bfine_arts_history_questions.json" },
                { name: "Math and Science History", file: "historybowlquestionsets/categories/b/bmath_science_history_questions.json" },
                { name: "Pop Culture/Sports History", file: "historybowlquestionsets/categories/b/bpop_culture_sports_history_questions.json" },
                { name: "Social Science/Philosophy", file: "historybowlquestionsets/categories/b/bsocial_science_philosophy_questions.json" },
                { name: "Literature History", file: "historybowlquestionsets/categories/b/bliterature_history_questions.json" },
                { name: "Recent History (2000-Present)", file: "historybowlquestionsets/categories/b/brecent_history_questions.json" },
                { name: "Mythology", file: "historybowlquestionsets/categories/b/bmythology_questions.json" },

                { name: "US History", file: "historybowlquestionsets/categories/c/cus_history_questions.json" },
                { name: "European History", file: "historybowlquestionsets/categories/c/ceuropean_history_questions.json" },
                { name: "World History", file: "historybowlquestionsets/categories/c/cworld_history_questions.json" },
                { name: "Other History", file: "historybowlquestionsets/categories/c/cother_history_questions.json" },
                { name: "Ancient History", file: "historybowlquestionsets/categories/c/cancient_history_questions.json" },
                { name: "Geographical History", file: "historybowlquestionsets/categories/c/cgeographical_history_questions.json" },
                { name: "Fine Arts History", file: "historybowlquestionsets/categories/c/cfine_arts_history_questions.json" },
                { name: "Math and Science History", file: "historybowlquestionsets/categories/c/cmath_science_history_questions.json" },
                { name: "Pop Culture/Sports History", file: "historybowlquestionsets/categories/c/cpop_culture_sports_history_questions.json" },
                { name: "Social Science/Philosophy", file: "historybowlquestionsets/categories/c/csocial_science_philosophy_questions.json" },
                { name: "Literature History", file: "historybowlquestionsets/categories/c/cliterature_history_questions.json" },
                { name: "Recent History (2000-Present)", file: "historybowlquestionsets/categories/c/crecent_history_questions.json" },
                { name: "Mythology", file: "historybowlquestionsets/categories/c/cmythology_questions.json" }
            ]
        },
        { year: "2014-2015", sets: [{ name: "Round 1", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRound9.json" },{ name: "Extra", file: "historybowlquestionsets/2014-2015/A2014-2015HistoryBowlRoundExtra.json" },{ name: "Round 1", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2014-2015/B2014-2015HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlRound9.json" },{ name: "Extras", file: "historybowlquestionsets/2014-2015/C2014-2015HistoryBowlExtras.json" }] },
        { year: "2015-2016", sets: [{ name: "Round 1", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2015-2016/A2015-2016HistoryBowlRound9.json" },{ name: "Round 1", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2015-2016/B2015-2016HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2015-2016/C2015-2016HistoryBowlRound10.json" }] },
        { year: "2016-2017", sets: [{ name: "Round 1", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2016-2017/A2016-2017HistoryBowlRound9.json" },{ name: "Round 1", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2016-2017/B2016-2017HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2016-2017/C2016-2017HistoryBowlRound10.json" }] },
        { year: "2017-2018", sets: [{ name: "Round 1", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2017-2018/A2017-2018HistoryBowlRound9.json" },{ name: "Round 1", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2017-2018/B2017-2018HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2017-2018/C2017-2018HistoryBowlRound10.json" }] },
        { year: "2018-2019", sets: [{ name: "Round 1", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2018-2019/A2018-2019HistoryBowlRound9.json" },{ name: "Round 1", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2018-2019/B2018-2019HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2018-2019/C2018-2019HistoryBowlRound10.json" }] },
        { year: "2019-2020", sets: [{ name: "Round 1", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2019-2020/A2019-2020HistoryBowlRound9.json" },{ name: "Round 1", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2019-2020/B2019-2020HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2019-2020/C2019-2020HistoryBowlRound10.json" }] },
        { year: "2020-2021", sets: [{ name: "Round 1", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlRound9.json" },{ name: "Extra", file: "historybowlquestionsets/2020-2021/A2020-2021HistoryBowlExtra.json" },{ name: "Round 1", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2020-2021/B2020-2021HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2020-2021/C2020-2021HistoryBowlRound10.json" }] },
        { year: "2021-2022", sets: [{ name: "Round 1", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2021-2022/A2021-2022HistoryBowlRound9.json" },{ name: "Round 1", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2021-2022/B2021-2022HistoryBowlRound10.json" },{ name: "Round 1", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound1.json" },{ name: "Round 2", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound2.json" },{ name: "Round 3", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound3.json" },{ name: "Round 4", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound4.json" },{ name: "Round 5", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound5.json" },{ name: "Round 6", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound6.json" },{ name: "Round 7", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound7.json" },{ name: "Round 8", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound8.json" },{ name: "Round 9", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound9.json" },{ name: "Round 10", file: "historybowlquestionsets/2021-2022/C2021-2022HistoryBowlRound10.json" }] },
        { year: "2022-2023", sets: [] },
        { year: "2023-2024", sets: [] },
        { year: "2024-2025", sets: [] }
];

(function () {
  console.log('MSM IIFE running');

  /* ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function nq(text) {
    return String(text || '').toLowerCase().replace(/\s+/g, ' ').trim().slice(0, 100);
  }

  function isMastered(quarter, questionText) {
    return masteredQuestions.has(`Q${quarter}|${nq(questionText)}`);
  }

  function countMastered(quarter, questions) {
    return questions.filter(q => isMastered(quarter, q)).length;
  }

  // Human-readable label from file path
  function labelFromFile(file) {
    // categories/a/aus_history_questions.json ‚Üí "US History"
    let m = file.match(/\/categories\/[a-c]\/[abc](.+?)_questions\.json/i);
    if (m) {
      return m[1].replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }
    // 2014-2015/A2014-2015HistoryBowlRound3.json ‚Üí "Round 3"
    m = file.match(/Round(\d+)\.json/i);
    if (m) return `Round ${parseInt(m[1])}`;
    m = file.match(/Extra[s]?\.json/i);
    if (m) return 'Extra';
    return file.split('/').pop().replace('.json', '');
  }

  /* ‚îÄ‚îÄ Cache for loaded set data ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const _setCache = {};
  async function loadSet(file) {
    if (_setCache[file]) return _setCache[file];
    try {
      const r = await fetch(file);
      if (!r.ok) return null;
      const d = await r.json();
      _setCache[file] = d;
      return d;
    } catch { return null; }
  }

  /* ‚îÄ‚îÄ Extract question texts from a loaded set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function extractQuestions(data) {
    const q1 = (data.q1 || []).map(q => q.question || '');
    const q2 = (data.q2 || []).map(q => q.tossup?.question || '');
    const q4 = (data.q4 || []).map(q => (q.parts || []).join(' '));
    return { q1, q2, q4 };
  }

  /* ‚îÄ‚îÄ Build stats for one file ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function statsForFile(file) {
    const data = await loadSet(file);
    if (!data) return null;
    const { q1, q2, q4 } = extractQuestions(data);
    return {
      q1: { mastered: countMastered(1, q1), total: q1.length },
      q2: { mastered: countMastered(2, q2), total: q2.length },
      q4: { mastered: countMastered(4, q4), total: q4.length },
    };
  }

  /* ‚îÄ‚îÄ Reset mastered keys for a set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
  async function resetSet(file) {
    const data = await loadSet(file);
    if (!data) return;
    const { q1, q2, q4 } = extractQuestions(data);
    q1.forEach(t => masteredQuestions.delete(`Q1|${nq(t)}`));
    q2.forEach(t => masteredQuestions.delete(`Q2|${nq(t)}`));
    q4.forEach(t => masteredQuestions.delete(`Q4|${nq(t)}`));
  }

  /* ‚îÄ‚îÄ Modal HTML skeleton ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function injectModal() {
    if (document.getElementById('masteredStatsModal')) return;
    document.body.insertAdjacentHTML('beforeend', `
<style>
.msm-box {
  background:#1a1630;
  border:1.5px solid #6c63ff44;
  border-radius:20px;
  width:min(900px,96vw);
  max-height:90vh;
  display:flex;flex-direction:column;
  box-shadow:0 24px 80px rgba(90,60,200,.35);
  overflow:hidden;
  font-family:"Segoe UI",Tahoma,sans-serif;
}
.msm-header {
  padding:22px 28px 16px;
  background:linear-gradient(135deg,#2d2060,#1a1630);
  border-bottom:1px solid #6c63ff33;
  display:flex;justify-content:space-between;align-items:center;
  flex-shrink:0;
}
.msm-header h2 {
  color:#c4b8ff;font-size:1.3rem;font-weight:700;margin:0;
  text-shadow:0 0 20px #6c63ff88;
}
.msm-close {
  background:none;border:none;color:#8b85aa;font-size:1.4rem;
  cursor:pointer;padding:4px 8px;border-radius:6px;transition:.15s;
}
.msm-close:hover{background:#ffffff1a;color:#fff;}
.msm-tabs {
  display:flex;gap:4px;padding:14px 24px 0;
  background:#1a1630;border-bottom:1px solid #6c63ff22;
  flex-wrap:wrap;flex-shrink:0;overflow-x:auto;
}
.msm-tab {
  padding:7px 14px;border-radius:8px 8px 0 0;border:none;
  background:#2a2248;color:#8b85aa;font-size:.79rem;font-weight:600;
  cursor:pointer;transition:.15s;letter-spacing:.3px;white-space:nowrap;
  flex-shrink:0;
}
.msm-tab:hover{background:#352d60;color:#c4b8ff;}
.msm-tab.active{
  background:linear-gradient(135deg,#5a4fd8,#7c63f0);
  color:#fff;box-shadow:0 4px 12px #5a4fd855;
}
.msm-body {
  flex:1;overflow-y:auto;padding:18px 24px;
  scrollbar-width:thin;scrollbar-color:#5a4fd8 #1a1630;
}
.msm-body::-webkit-scrollbar{width:6px;}
.msm-body::-webkit-scrollbar-thumb{background:#5a4fd8;border-radius:3px;}
.msm-loading {
  text-align:center;padding:50px;color:#8b85aa;font-size:1rem;
}
.msm-spinner {
  width:32px;height:32px;border:3px solid #5a4fd833;
  border-top:3px solid #7c63f0;border-radius:50%;
  animation:msm-spin 1s linear infinite;margin:0 auto 16px;
}
@keyframes msm-spin{to{transform:rotate(360deg);}}

/* Set group cards */
.msm-group { margin-bottom:14px; }
.msm-group-header {
  display:flex;justify-content:space-between;align-items:center;
  background:#22193d;border:1px solid #5a4fd822;
  border-radius:10px 10px 0 0;padding:10px 14px;
  cursor:pointer;user-select:none;
}
.msm-group-header:hover{background:#2a2050;}
.msm-group-title {
  color:#c4b8ff;font-weight:700;font-size:.9rem;
  display:flex;align-items:center;gap:8px;
}
.msm-group-arrow { color:#6c63ff;font-size:.75rem;transition:.2s; }
.msm-group-arrow.open{transform:rotate(90deg);}
.msm-group-pct {
  font-size:.78rem;color:#8b85aa;background:#5a4fd822;
  padding:2px 10px;border-radius:20px;
}
.msm-group-body { display:none; }
.msm-group-body.open {
  display:block;background:#1e1838;
  border:1px solid #5a4fd822;border-top:none;
  border-radius:0 0 10px 10px;overflow:hidden;
}

/* Set row */
.msm-row {
  display:grid;
  grid-template-columns:20px 1fr auto auto auto 72px;
  gap:10px;align-items:center;
  padding:8px 14px;
  border-bottom:1px solid #5a4fd811;
  transition:.12s;
}
.msm-row:last-child{border-bottom:none;}
.msm-row:hover{background:#2a2050;}
.msm-check {
  width:15px;height:15px;cursor:pointer;accent-color:#7c63f0;
  flex-shrink:0;
}
.msm-label { color:#d4cfef;font-size:.83rem;font-weight:500; }
.msm-q-badge {
  font-size:.72rem;padding:2px 9px;border-radius:12px;
  font-weight:600;white-space:nowrap;
}
.msm-q-badge.q1{background:#1e3a5f;color:#60aeff;}
.msm-q-badge.q2{background:#2d1f4e;color:#b07fff;}
.msm-q-badge.q4{background:#1f3d2a;color:#5ad688;}
.msm-q-badge.zero{opacity:.35;}
.msm-bar-wrap{height:6px;background:#ffffff18;border-radius:3px;overflow:hidden;}
.msm-bar-fill{height:100%;background:linear-gradient(90deg,#5a4fd8,#9c83ff);transition:width .4s;}

.msm-footer {
  padding:14px 24px;background:#1a1630;
  border-top:1px solid #6c63ff22;
  display:flex;justify-content:space-between;align-items:center;
  flex-shrink:0;gap:12px;flex-wrap:wrap;
}
.msm-sel-info { color:#8b85aa;font-size:.83rem; }
.msm-sel-btns { display:flex;gap:6px;flex-wrap:wrap;margin-top:5px; }
.msm-btn {
  padding:8px 18px;border-radius:8px;border:none;
  font-weight:700;font-size:.83rem;cursor:pointer;transition:.15s;
}
.msm-btn.reset {
  background:linear-gradient(135deg,#dc3545,#c82333);
  color:#fff;box-shadow:0 2px 10px #dc354544;
}
.msm-btn.reset:hover{box-shadow:0 4px 16px #dc354566;transform:translateY(-1px);}
.msm-btn.reset:disabled{opacity:.4;cursor:not-allowed;transform:none;}
.msm-btn.cancel {
  background:#2a2248;color:#c4b8ff;
  border:1.5px solid #5a4fd855;
}
.msm-btn.cancel:hover{background:#352d60;}
.msm-btn.sm {
  padding:4px 10px;font-size:.74rem;
  background:#2a2248;color:#c4b8ff;
  border:1px solid #5a4fd844;border-radius:6px;
}
.msm-btn.sm:hover{background:#352d60;}
</style>

<div id="masteredStatsModal" style="display:none;position:fixed;inset:0;z-index:99999;background:rgba(10,8,20,.72);backdrop-filter:blur(6px);align-items:center;justify-content:center;">
  <div class="msm-box">
    <div class="msm-header">
      <h2>üèÜ Mastered Questions ‚Äî Stats &amp; Reset</h2>
      <button class="msm-close" onclick="closeMasteredStatsModal()">‚úï</button>
    </div>
    <div class="msm-tabs" id="msmTabs"></div>
    <div class="msm-body" id="msmBody">
      <div class="msm-loading"><div class="msm-spinner"></div>Loading‚Ä¶</div>
    </div>
    <div class="msm-footer">
      <div>
        <div class="msm-sel-info" id="msmSelInfo">No sets selected</div>
        <div class="msm-sel-btns">
          <button class="msm-btn sm" onclick="msmSelectAll()">Select All Visible</button>
          <button class="msm-btn sm" onclick="msmDeselectAll()">Deselect All</button>
        </div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;">
        <button class="msm-btn cancel" onclick="closeMasteredStatsModal()">Close</button>
        <button class="msm-btn reset" id="msmResetBtn" disabled onclick="msmDoReset()">
          Reset Selected
        </button>
      </div>
    </div>
  </div>
</div>
`);
  }

  /* ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  let _msmCurrentTabIdx = 0;
  let _msmSelected = new Set(); // file paths selected for reset
  let _msmTabData = [];

  /* ‚îÄ‚îÄ Open modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
  window.showMasteredStats = async function () {
    injectModal();
    const _msmEl = document.getElementById('masteredStatsModal');
    _msmEl.setAttribute('style', _msmEl.getAttribute('style').replace('display:none;', ''));
    _msmEl.style.display = 'flex';
    _msmTabData = window.AVAILABLE_FILES || [];
    _msmSelected = new Set();
    _msmCurrentTabIdx = 0;
    buildTabs();
    await renderTab(0);
  };

  window.closeMasteredStatsModal = function () {
    document.getElementById('masteredStatsModal').style.display = 'none';
  };

  /* ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function buildTabs() {
    const container = document.getElementById('msmTabs');
    container.innerHTML = '';
    _msmTabData.forEach((group, idx) => {
      const btn = document.createElement('button');
      btn.className = 'msm-tab' + (idx === 0 ? ' active' : '');
      btn.textContent = group.year;
      btn.onclick = async () => {
        document.querySelectorAll('.msm-tab').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        _msmCurrentTabIdx = idx;
        await renderTab(idx);
      };
      container.appendChild(btn);
    });
  }

  /* ‚îÄ‚îÄ Render a tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function renderTab(tabIdx) {
    const body = document.getElementById('msmBody');
    body.innerHTML = '<div class="msm-loading"><div class="msm-spinner"></div>Loading sets‚Ä¶</div>';
    updateSelInfo();

    const group = _msmTabData[tabIdx];
    if (!group || !group.sets || group.sets.length === 0) {
      body.innerHTML = '<div class="msm-loading" style="color:#8b85aa;">No sets available for this year.</div>';
      return;
    }

    const isCatTab = group.year === 'Categories';
    if (isCatTab) {
      await renderCategoryTab(group.sets, body);
    } else {
      await renderYearTab(group.sets, body);
    }
    updateSelInfo();
  }

  /* ‚îÄ‚îÄ Category tab: group by Set A / B / C ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function renderCategoryTab(sets, body) {
    const byLetter = {};
    sets.forEach(set => {
      const m = set.file.match(/\/categories\/([a-c])\//i);
      const letter = m ? m[1].toUpperCase() : '?';
      if (!byLetter[letter]) byLetter[letter] = [];
      byLetter[letter].push(set);
    });
    body.innerHTML = '';
    for (const letter of Object.keys(byLetter).sort()) {
      const groupEl = await buildSetGroup(`Set ${letter}`, byLetter[letter]);
      body.appendChild(groupEl);
    }
  }

  /* ‚îÄ‚îÄ Year tab: group by set letter ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function renderYearTab(sets, body) {
    const byLetter = {};
    sets.forEach(set => {
      const m = set.file.match(/\/([ABC])\d{4}-\d{4}/i);
      const letter = m ? m[1].toUpperCase() : 'Other';
      if (!byLetter[letter]) byLetter[letter] = [];
      byLetter[letter].push(set);
    });
    body.innerHTML = '';
    for (const letter of Object.keys(byLetter).sort()) {
      const groupEl = await buildSetGroup(`Set ${letter}`, byLetter[letter]);
      body.appendChild(groupEl);
    }
  }

  /* ‚îÄ‚îÄ Build a collapsible set group ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function buildSetGroup(title, sets) {
    const wrapper = document.createElement('div');
    wrapper.className = 'msm-group';

    // Load all stats in parallel
    const statsArr = await Promise.all(sets.map(s => statsForFile(s.file)));

    // Aggregate totals for header
    let gM = 0, gT = 0;
    statsArr.forEach(st => {
      if (!st) return;
      gM += st.q1.mastered + st.q2.mastered + st.q4.mastered;
      gT += st.q1.total + st.q2.total + st.q4.total;
    });
    const gPct = gT ? Math.round(100 * gM / gT) : 0;

    const header = document.createElement('div');
    header.className = 'msm-group-header';
    // Use a data attribute to avoid quote escaping issues in onclick
    header.innerHTML = `
      <div class="msm-group-title">
        <span class="msm-group-arrow">‚ñ∂</span>
        ${title}
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <span class="msm-group-pct">${gM}/${gT} &nbsp;${gPct}%</span>
        <button class="msm-btn sm" data-group="${title}" data-action="select"
          onclick="event.stopPropagation();msmGroupToggle(this)">
          Select All
        </button>
        <button class="msm-btn sm" data-group="${title}" data-action="deselect"
          onclick="event.stopPropagation();msmGroupToggle(this)">
          Deselect All
        </button>
      </div>
    `;

    const groupBody = document.createElement('div');
    groupBody.className = 'msm-group-body';
    groupBody.dataset.groupTitle = title;

    sets.forEach((set, i) => {
      groupBody.appendChild(buildSetRow(set, statsArr[i]));
    });

    // Toggle collapse on header click
    header.addEventListener('click', e => {
      if (e.target.tagName === 'BUTTON') return;
      header.querySelector('.msm-group-arrow').classList.toggle('open');
      groupBody.classList.toggle('open');
    });

    // Auto-open if any mastered in this group
    if (gM > 0) {
      header.querySelector('.msm-group-arrow').classList.add('open');
      groupBody.classList.add('open');
    }

    wrapper.appendChild(header);
    wrapper.appendChild(groupBody);
    return wrapper;
  }

  /* ‚îÄ‚îÄ Build one set row ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function buildSetRow(set, st) {
    const row = document.createElement('div');
    row.className = 'msm-row';
    row.dataset.file = set.file;

    const totalM = st ? (st.q1.mastered + st.q2.mastered + st.q4.mastered) : 0;
    const totalQ = st ? (st.q1.total + st.q2.total + st.q4.total) : 0;
    const pct = totalQ ? Math.round(100 * totalM / totalQ) : 0;

    // Checkbox
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.className = 'msm-check';
    cb.checked = _msmSelected.has(set.file);
    cb.addEventListener('change', () => {
      if (cb.checked) _msmSelected.add(set.file);
      else _msmSelected.delete(set.file);
      updateSelInfo();
    });
    row.appendChild(cb);

    // Label
    const lbl = document.createElement('div');
    lbl.className = 'msm-label';
    lbl.textContent = labelFromFile(set.file);
    row.appendChild(lbl);

    if (st) {
      [['q1',1],['q2',2],['q4',4]].forEach(([cls, n]) => {
        const badge = document.createElement('div');
        badge.className = `msm-q-badge ${cls}${st[cls].total === 0 ? ' zero' : ''}`;
        badge.textContent = `Q${n}: ${st[cls].mastered}/${st[cls].total}`;
        row.appendChild(badge);
      });
    } else {
      const err = document.createElement('div');
      err.style.cssText = 'color:#e53e3e;font-size:.78rem;grid-column:3/6;';
      err.textContent = 'Failed to load';
      row.appendChild(err);
    }

    // Mini progress bar
    const barWrap = document.createElement('div');
    barWrap.className = 'msm-bar-wrap';
    const barFill = document.createElement('div');
    barFill.className = 'msm-bar-fill';
    barFill.style.width = pct + '%';
    barWrap.appendChild(barFill);
    row.appendChild(barWrap);

    return row;
  }

  /* ‚îÄ‚îÄ Selection helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  window.msmSelectAll = function () {
    document.querySelectorAll('#msmBody .msm-check').forEach(cb => {
      cb.checked = true;
      _msmSelected.add(cb.closest('.msm-row').dataset.file);
    });
    updateSelInfo();
  };

  window.msmDeselectAll = function () {
    document.querySelectorAll('#msmBody .msm-check').forEach(cb => {
      cb.checked = false;
    });
    _msmSelected.clear();
    updateSelInfo();
  };

  window.msmGroupToggle = function (btn) {
    const title = btn.dataset.group;
    const action = btn.dataset.action;
    const group = document.querySelector(`.msm-group-body[data-group-title="${title}"]`);
    if (!group) return;
    group.querySelectorAll('.msm-check').forEach(cb => {
      cb.checked = action === 'select';
      const file = cb.closest('.msm-row').dataset.file;
      if (action === 'select') _msmSelected.add(file);
      else _msmSelected.delete(file);
    });
    updateSelInfo();
  };

  function updateSelInfo() {
    const selInfo = document.getElementById('msmSelInfo');
    const resetBtn = document.getElementById('msmResetBtn');
    if (!selInfo || !resetBtn) return;
    const n = _msmSelected.size;
    selInfo.textContent =
      n === 0 ? 'No sets selected' : `${n} set${n !== 1 ? 's' : ''} selected for reset`;
    resetBtn.disabled = n === 0;
  }

  /* ‚îÄ‚îÄ Reset ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  window.msmDoReset = async function () {
    const n = _msmSelected.size;
    if (n === 0) return;
    if (!confirm(
      `Reset mastered questions for ${n} selected set${n !== 1 ? 's' : ''}?\n` +
      `Those questions will reappear in practice mode.`
    )) return;

    const btn = document.getElementById('msmResetBtn');
    btn.disabled = true;
    btn.textContent = 'Resetting‚Ä¶';

    for (const file of _msmSelected) {
      await resetSet(file);
    }
    await saveMasteredQuestions();
    _msmSelected.clear();

    btn.textContent = '‚úì Done!';
    setTimeout(async () => {
      btn.textContent = 'Reset Selected';
      await renderTab(_msmCurrentTabIdx);
    }, 1000);
  };

  // Override old simple function to open the new modal
  window.confirmResetMastered = function () {
    window.showMasteredStats();
  };

})();
</script>
</body>
</html>
